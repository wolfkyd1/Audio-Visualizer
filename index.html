<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Audio Visualizer Pro</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(45deg, #0f0f23, #1a1a2e, #16213e);
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            height: 100vh;
            transition: background 0.5s ease;
        }

        body.dark {
            background: #000000;
        }

        body.stars {
        background: #000;
        background-image: 
            /* Bright stars */
            radial-gradient(2px 2px at 10% 20%, rgba(255,255,255,0.9), transparent),
            radial-gradient(3px 3px at 70% 30%, rgba(255,255,255,0.9), transparent),
            radial-gradient(2px 2px at 85% 60%, rgba(255,255,255,0.8), transparent),

            /* Medium stars */
            radial-gradient(2px 2px at 25% 40%, rgba(255,255,255,0.6), transparent),
            radial-gradient(3px 3px at 15% 85%, rgba(255,255,255,0.5), transparent),
            radial-gradient(2px 2px at 60% 75%, rgba(255,255,255,0.5), transparent),

            /* Dim stars */
            radial-gradient(2px 2px at 5% 95%, rgba(200,200,255,0.3), transparent),
            radial-gradient(2px 2px at 95% 15%, rgba(255,255,200,0.25), transparent),
            radial-gradient(2px 2px at 55% 45%, rgba(220,220,220,0.2), transparent);
        
        background-repeat: repeat;
        background-size: 300px 300px;

        /* Twinkling effect */
        animation: twinkle 1s infinite alternate ease-in-out;
        }

        @keyframes twinkle {
        0%   { opacity: 0.8; }
        50%  { opacity: 1; }
        100% { opacity: 0.6; }
        }

        body.matrix {
        background: 
            /* vertical streaks overlay */
            repeating-linear-gradient(
            180deg,rgba(0, 255, 0, 0.05) 0px, rgba(0, 255, 0, 0.05) 2px, transparent 2px, transparent 40px),
            /* animated glowing gradient */
            linear-gradient(135deg, #0f1419 0%, #0a0f0a 25%, #001100 50%, #002200 75%,#0d1f0d 100%);

        background-size: 100% 200%, 200% 200%;
        background-attachment: fixed;
        animation: matrixRain 20s linear infinite, matrixGlow 15s ease-in-out infinite alternate;
        }

        @keyframes matrixGlow {
        0%   { background-position: 0% 50%, 0% 50%; }
        50%  { background-position: 100% 50%, 100% 50%; }
        100% { background-position: 0% 50%, 0% 50%; }
        }

        @keyframes matrixRain {
        0%   { background-position: 0 0, 0 50%; }
        100% { background-position: 0 1000px, 0 50%; }
        }

        body.cosmic {
        background: #000; /* space black */

        /* stars */
        background-image: 
            radial-gradient(1px 1px at 10px 20px, #fff, transparent),
            radial-gradient(2px 2px at 40px 70px, rgba(255,255,255,0.8), transparent),
            radial-gradient(1px 1px at 90px 40px, rgba(255,255,255,0.6), transparent),
            radial-gradient(1px 2px at 130px 80px, rgba(255,255,255,0.5), transparent),
            radial-gradient(2px 1px at 160px 30px, rgba(255,255,255,0.7), transparent),

            /* colorful nebula blobs */
            radial-gradient(circle at 60px 200px, rgba(18, 4, 88, 0.6), transparent 60%),
            radial-gradient(circle at 250px 50px, rgba(255, 107, 160, 0.5), transparent 60%),
            radial-gradient(circle at 180px 150px, rgba(78, 205, 196, 0.4), transparent 70%),
            radial-gradient(circle at 300px 250px, rgba(180, 50, 255, 0.3), transparent 70%);

        background-repeat: repeat;
        background-size: 400px 400px;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #webgl-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(10, 10, 30, 0.95);
            backdrop-filter: blur(15px);
            border-radius: 15px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 255, 255, 0.2);
            transition: all 0.3s ease;
            min-width: 320px;
            max-height: 80vh;
            overflow-y: auto;
        }

        #controls:hover {
            border-color: rgba(0, 255, 255, 0.6);
            box-shadow: 0 12px 48px rgba(0, 255, 255, 0.3);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group.hidden {
            display: none;
        }

        label {
            display: block;
            color: #00ffff;
            font-size: 11px;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
            cursor: help;
        }

        select, input, button {
            background: rgba(15, 15, 35, 0.9);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 6px;
            color: #00ffff;
            padding: 8px 12px;
            font-size: 11px;
            width: 100%;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        select {
            background-color: rgba(15, 15, 35, 0.95);
        }

        select option {
            background-color: #0f0f23;
            color: #00ffff;
            padding: 5px;
        }

        select:hover, input:hover, button:hover {
            border-color: rgba(0, 255, 255, 0.6);
            background: rgba(20, 20, 40, 0.9);
            transform: translateY(-1px);
        }

        button {
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
            text-align: center;
        }

        button:active {
            transform: scale(0.95);
        }

        button.active {
            background: rgba(0, 255, 255, 0.3);
            border-color: rgba(0, 255, 255, 0.8);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
        }

        #fullscreen-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 200;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 1px solid rgba(0, 255, 255, 0.3);
            background: rgba(10, 10, 30, 0.9);
            backdrop-filter: blur(10px);
            color: #00ffff;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        #fullscreen-btn:hover {
            border-color: rgba(0, 255, 255, 0.8);
            background: rgba(0, 255, 255, 0.2);
            transform: scale(1.1);
        }

        #status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            color: rgba(0, 255, 255, 0.8);
            font-size: 11px;
            background: rgba(10, 10, 30, 0.8);
            padding: 12px 18px;
            border-radius: 25px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(10px);
        }

        .glow {
            filter: drop-shadow(0 0 15px rgba(0, 255, 255, 0.5));
        }

        input[type="range"] {
            -webkit-appearance: none;
            height: 4px;
            background: rgba(0, 255, 255, 0.2);
            border-radius: 2px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: linear-gradient(45deg, #00ffff, #0080ff);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.6);
            border: 1px solid rgba(0, 255, 255, 0.8);
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: linear-gradient(45deg, #00ffff, #0080ff);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.6);
            border: 1px solid rgba(0, 255, 255, 0.8);
        }

        .info {
            position: absolute;
            top: 20px;
            right: 90px;
            z-index: 100;
            color: rgba(0, 255, 255, 0.6);
            font-size: 10px;
            text-align: right;
            line-height: 1.4;
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }

        .advanced-controls {
            background: rgba(5, 5, 15, 0.8);
            border-radius: 8px;
            padding: 12px;
            margin-top: 10px;
            border: 1px solid rgba(0, 255, 255, 0.2);
        }

        .control-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 8px;
        }

        .control-row .control-group {
            margin-bottom: 5px;
        }

        .control-row label {
            font-size: 9px;
            margin-bottom: 3px;
        }

        .control-row input {
            padding: 4px 8px;
            font-size: 10px;
        }

        .error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 1000;
            display: none;
        }

        .performance-indicator {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(10, 10, 30, 0.8);
            padding: 8px 12px;
            border-radius: 15px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            font-size: 10px;
            color: #00ffff;
        }

        /* Auto-hide controls in fullscreen */
        body:-webkit-full-screen #controls,
        body:-moz-full-screen #controls,
        body:fullscreen #controls {
            opacity: 0.3;
            transition: opacity 0.3s ease;
        }

        body:-webkit-full-screen #controls:hover,
        body:-moz-full-screen #controls:hover,
        body:fullscreen #controls:hover {
            opacity: 1;
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            #controls {
                top: 10px;
                left: 10px;
                right: 10px;
                width: auto;
                padding: 15px;
                max-height: 70vh;
            }
            
            #fullscreen-btn {
                top: 10px;
                right: 10px;
            }
            
            #status {
                bottom: 10px;
                left: 10px;
                right: 10px;
                text-align: center;
            }

            .control-row {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="webgl-canvas"></canvas>
    </div>
    
    <div class="error-message" id="error-message">
        <h3>WebGL Error</h3>
        <p id="error-text">An error occurred while initializing the visualizer.</p>
        <button onclick="document.getElementById('error-message').style.display='none'">Close</button>
    </div>
    
    <div class="info">
        <div>Press F11 for fullscreen</div>
        <div>Use 1-7 keys to switch modes</div>
        <div>Space to start/stop audio</div>
        <div>H to hide/show controls</div>
    </div>

    <div id="fullscreen-btn" title="Toggle Fullscreen">⛶</div>

    <div class="performance-indicator">
        <div>GPU: <span id="gpu-info">Detecting...</span></div>
        <div>Quality: <span id="quality-level">High</span></div>
    </div>

    <div id="controls" class="glow">
        <div class="control-group">
            <label>🎵 Audio Source</label>
            <button id="start-capture" class="pulse">🎤 Start Microphone</button>
        </div>
        
        <div class="control-group">
            <label>🎨 Visualizer Mode</label>
            <select id="visualizer-mode">
                <option value="fractal">🌀 Fractal Reactor</option>
                <option value="neural">🧠 Neural Network</option>
                <option value="tunnel">🕳️ 3D Tunnel</option>
                <option value="cosmic-spheres">🌌 Cosmic Spheres</option>
                <option value="psychedelic">🌈 Psychedelic Fractal</option>
                <option value="dmt">🔮 DMT Tunnel</option>
            </select>
        </div>

        <div class="control-group">
            <label>🌈 Color Theme</label>
            <select id="color-theme">
                <option value="cyan">💎 Cyan Glow</option>
                <option value="rainbow">🌈 Rainbow</option>
                <option value="fire">🔥 Fire</option>
                <option value="electric">⚡ Electric Blue</option>
                <option value="neon">💖 Neon Pink</option>
                <option value="matrix">💚 Matrix Green</option>
                <option value="sunset">🌅 Sunset</option>
                <option value="cosmic">🌌 Cosmic Purple</option>
            </select>
        </div>

        <div class="control-group" id="sensitivity-group">
            <label title="Controls how much the visualizer responds to audio input">🎛️ Sensitivity: <span id="sensitivity-value">2.0</span></label>
            <input type="range" id="sensitivity" min="0.1" max="5" step="0.1" value="2">
        </div>

        <div class="control-group" id="speed-group">
            <label title="Controls animation speed and movement rate">⚡ Speed: <span id="speed-value">1.5</span></label>
            <input type="range" id="speed" min="0.1" max="4" step="0.1" value="1.5">
        </div>

        <div class="control-group" id="intensity-group">
            <label title="Controls brightness and overall energy of the effects">🔥 Intensity: <span id="intensity-value">2.0</span></label>
            <input type="range" id="intensity" min="0.1" max="5" step="0.1" value="2">
        </div>

        <div class="advanced-controls">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                <label>⚙️ Advanced Controls</label>
                <button id="reset-controls" style="width: auto; padding: 4px 12px; font-size: 10px;">🔄 Reset</button>
            </div>
            <div class="control-row">
                <div class="control-group" id="zoom-group">
                    <label title="Controls how zoomed in or out the visual effects appear">🔍 Zoom: <span id="zoom-value">1.0</span></label>
                    <input type="range" id="zoom" min="0.1" max="5" step="0.1" value="1">
                </div>
                <div class="control-group" id="contrast-group">
                    <label title="Controls the difference between light and dark areas">🌗 Contrast: <span id="contrast-value">1.2</span></label>
                    <input type="range" id="contrast" min="0.1" max="3" step="0.1" value="1.2">
                </div>
            </div>
            <div class="control-row">
                <div class="control-group" id="orbsize-group">
                    <label title="Controls the size of orbital movements and particle systems">⭕ Orbit Size: <span id="orbsize-value">1.0</span></label>
                    <input type="range" id="orbsize" min="0.1" max="3" step="0.1" value="1">
                </div>
                <div class="control-group" id="radius-group">
                    <label title="Controls the overall scale and spread of visual elements">🔍 Scale: <span id="radius-value">1.0</span></label>
                    <input type="range" id="radius" min="0.1" max="3" step="0.1" value="1">
                </div>
            </div>
            <div class="control-row">
                <div class="control-group" id="colorshift-group">
                    <label title="Controls how fast colors cycle and change over time">🎨 Color Shift: <span id="colorshift-value">1.5</span></label>
                    <input type="range" id="colorshift" min="0.1" max="5" step="0.1" value="1.5">
                </div>
                <div class="control-group" id="center-group">
                    <label title="Shifts the center point of the visualization horizontally">🎯 Center X: <span id="center-value">0.0</span></label>
                    <input type="range" id="center" min="-2" max="2" step="0.1" value="0">
                </div>
            </div>
            <div class="control-row">
                <div class="control-group" id="sides-group">
                    <label title="Controls symmetry - number of repeated segments in kaleidoscope effects">🔢 Symmetry: <span id="sides-value">6</span></label>
                    <input type="range" id="sides" min="3" max="20" step="1" value="6">
                </div>
                <div class="control-group" id="rotation-group">
                    <label title="Controls rotation speed of spinning elements">🌀 Rotation: <span id="rotation-value">0.8</span></label>
                    <input type="range" id="rotation" min="0.1" max="5" step="0.1" value="0.8">
                </div>
            </div>
            <div class="control-row">
                <div class="control-group" id="warp-group">
                    <label title="Controls distortion and warping effects on the visuals">🌊 Warp: <span id="warp-value">0.3</span></label>
                    <input type="range" id="warp" min="0.0" max="2" step="0.1" value="0.3">
                </div>
                <div class="control-group" id="maxiter-group">
                    <label title="Controls detail level - higher values give more complex fractals">🎭 Iterations: <span id="maxiter-value">50</span></label>
                    <input type="range" id="maxiter" min="20" max="200" step="10" value="50">
                </div>
            </div>
            <div class="control-row">
                <div class="control-group" id="flow-group">
                    <label title="Controls how smoothly elements flow and transition">💫 Flow Speed: <span id="flow-value">1.0</span></label>
                    <input type="range" id="flow" min="0.1" max="3" step="0.1" value="1.0">
                </div>
                <div class="control-group" id="complexity-group">
                    <label title="Controls how intricate and detailed the patterns become">🔬 Complexity: <span id="complexity-value">1.2</span></label>
                    <input type="range" id="complexity" min="0.5" max="3" step="0.1" value="1.2">
                </div>
            </div>
            <div class="control-row">
                <div class="control-group" id="distortion-group">
                    <label title="Controls waviness and bending effects on the entire visual">🌀 Distortion: <span id="distortion-value">0.5</span></label>
                    <input type="range" id="distortion" min="0.0" max="2" step="0.1" value="0.5">
                </div>
                <div class="control-group" id="kaleidoscope-group">
                    <label title="Controls strength of mirror and kaleidoscope effects">💎 Kaleidoscope: <span id="kaleidoscope-value">1.0</span></label>
                    <input type="range" id="kaleidoscope" min="0.0" max="3" step="0.1" value="1.0">
                </div>
            </div>
            <div class="control-row">
                <div class="control-group" id="morphing-group">
                    <label title="Controls how shapes transform and change over time">🔄 Morphing: <span id="morphing-value">0.8</span></label>
                    <input type="range" id="morphing" min="0.0" max="2" step="0.1" value="0.8">
                </div>
                <div class="control-group" id="fractal-group">
                    <label title="Controls depth and recursiveness of fractal patterns">🌿 Fractal Depth: <span id="fractal-value">1.0</span></label>
                    <input type="range" id="fractal" min="0.5" max="3" step="0.1" value="1.0">
                </div>
            </div>
        </div>

        <div class="control-group">
            <label>🎭 Background</label>
            <select id="background-mode">
                <option value="gradient">🌌 Gradient</option>
                <option value="dark">🌑 Dark</option>
                <option value="stars">✨ Stars</option>
                <option value="matrix">💚 Matrix</option>
                <option value="cosmic">🪐 Cosmic</option>
            </select>
        </div>
    </div>

    <div id="status">
        <div>🎵 Status: <span id="audio-status">Click Start Microphone</span></div>
        <div>📊 FPS: <span id="fps-counter">0</span></div>
        <div>🎨 Mode: <span id="current-mode">Fractal Reactor</span></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        class UltimateAudioVisualizer {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.audioContext = null;
                this.analyser = null;
                this.dataArray = null;
                this.source = null;
                this.currentVisualizer = null;
                this.isCapturing = false;
                this.animationId = null;
                this.isWebGLSupported = true;
                this.performanceLevel = 'high';
                this.controlsVisible = true;
                
                this.settings = {
                    sensitivity: 2,
                    speed: 1.5,
                    intensity: 2,
                    colorTheme: 'cyan',
                    backgroundMode: 'gradient',
                    visualizerMode: 'fractal',
                    zoom: 1,
                    contrast: 1.2,
                    orbsize: 1,
                    radius: 1,
                    colorshift: 1.5,
                    center: 0,
                    sides: 6,
                    rotation: 0.8,
                    warp: 0.3,
                    maxiter: 50,
                    flow: 1.0,
                    complexity: 1.2,
                    distortion: 0.5,
                    kaleidoscope: 1.0,
                    morphing: 0.8,
                    fractal: 1.0
                };

                this.audioAnalysis = {
                    bass: 0, mid: 0, treble: 0, peak: 0, average: 0, history: [], 
                    rms: 0, beat: false, energyTrend: 0
                };

                this.modeControls = {
                    fractal: ['sensitivity', 'speed', 'intensity', 'zoom', 'contrast', 'orbsize', 'colorshift', 'center', 'rotation'],
                    neural: ['sensitivity', 'speed', 'intensity', 'zoom', 'contrast', 'orbsize', 'colorshift', 'rotation'],
                    tunnel: ['sensitivity', 'speed', 'intensity', 'zoom', 'contrast', 'colorshift', 'center', 'rotation', 'orbsize', 'warp'],
                    'cosmic-spheres': ['sensitivity', 'speed', 'intensity', 'zoom', 'contrast', 'orbsize', 'radius', 'colorshift', 'center', 'rotation', 'warp', 'flow', 'sides', 'complexity'],
                    psychedelic: ['sensitivity', 'speed', 'intensity', 'zoom', 'contrast', 'colorshift', 'center', 'sides', 'rotation', 'warp', 'maxiter', 'distortion', 'kaleidoscope', 'morphing', 'fractal'],
                    dmt: ['sensitivity', 'speed', 'intensity', 'zoom', 'contrast', 'colorshift', 'center', 'rotation', 'warp', 'flow', 'complexity']
                };

                this.modeDefaults = {
                    fractal: {
                        sensitivity: 2.2, speed: 1.0, intensity: 2.2, zoom: 0.4, contrast: 1.4,
                        orbsize: 2.0, radius: 1.0, colorshift: 0.9, center: 0.0, sides: 16,
                        rotation: 0.9, warp: 0.2, maxiter: 40, flow: 1.0, complexity: 2.0,
                        distortion: 0.3, kaleidoscope: 0.8, morphing: 0.5, fractal: 0.8
                    },
                    neural: {
                        sensitivity: 2.2, speed: 1.4, intensity: 2.4, zoom: 1.0, contrast: 1.6,
                        orbsize: 0.8, radius: 1.0, colorshift: 1.4, center: 0.0, sides: 6,
                        rotation: 0.5, warp: 0.1, maxiter: 30, complexity: 0.8,
                        distortion: 0.1, morphing: 0.3, fractal: 0.5
                    },
                    tunnel: {
                        sensitivity: 2.5, speed: 1.8, intensity: 2.0, zoom: 1.0, contrast: 1.4,
                        orbsize: 1.2, radius: 1.0, colorshift: 1.8, center: 0.0, sides: 6,
                        rotation: 0.6, warp: 0.4, maxiter: 25, flow: 1.0, complexity: 0.8,
                        distortion: 0.2, kaleidoscope: 0.6, morphing: 0.4, fractal: 0.7
                    },
                    'cosmic-spheres': {
                        sensitivity: 2.8, speed: 1.6, intensity: 2.4, zoom: 1.0, contrast: 1.6,
                        orbsize: 1.2, radius: 1.8, colorshift: 2.2, center: 0.0, sides: 5,
                        rotation: 0.8, warp: 0.6, maxiter: 30, flow: 1.4, complexity: 1.6,
                        distortion: 0.3, kaleidoscope: 0.8, morphing: 0.5, fractal: 0.8
                    },
                    psychedelic: {
                        sensitivity: 3.0, speed: 1.2, intensity: 0.8, zoom: 1.2, contrast: 0.5,
                        orbsize: 1.4, radius: 1.4, colorshift: 1.4, center: 0.0, sides: 9,
                        rotation: 0.5, warp: 0.6, maxiter: 80, flow: 1.0, complexity: 1.2,
                        distortion: 0.3, kaleidoscope: 2.3, morphing: 0.4, fractal: 2.8
                    },
                    dmt: {
                        sensitivity: 3.2, speed: 1.0, intensity: 3.0, zoom: 1.3, contrast: 2.0,
                        orbsize: 1.5, radius: 1.6, colorshift: 2.8, center: 0.0, sides: 8,
                        rotation: 0.6, warp: 0.8, maxiter: 100, flow: 1.6, complexity: 1.8,
                        distortion: 1.0, kaleidoscope: 1.8, morphing: 1.5, fractal: 2.0
                    }
                };

                this.colorThemes = {
                    cyan: { primary: 0x00ffff, secondary: 0x0080ff, accent: 0x00ff80 },
                    rainbow: { primary: 0xff0080, secondary: 0x8000ff, accent: 0x00ff80 },
                    fire: { primary: 0xff4000, secondary: 0xff8000, accent: 0xffff00 },
                    electric: { primary: 0x0040ff, secondary: 0x4080ff, accent: 0x80c0ff },
                    neon: { primary: 0xff0080, secondary: 0xff4080, accent: 0xff80c0 },
                    matrix: { primary: 0x00ff41, secondary: 0x008f11, accent: 0x00ff88 },
                    sunset: { primary: 0xff6b35, secondary: 0xff8c42, accent: 0xffd23f },
                    cosmic: { primary: 0x9b59b6, secondary: 0x8e44ad, accent: 0x3498db }
                };

                this.fpsCounter = 0;
                this.lastFpsTime = performance.now();
                this.beatDetector = {
                    history: [],
                    threshold: 0.7,
                    lastBeat: 0,
                    energy: 0
                };
                this.spectrumAnalyzer = {
                    frequencyBands: 32,
                    smoothingFactor: 0.8,
                    bandData: new Array(32).fill(0)
                };

                this.init();
            }

            detectBeats(audioData, analysis) {
                if (!audioData) return false;
                
                // Calculate instantaneous energy
                let energy = 0;
                for (let i = 0; i < Math.min(audioData.length * 0.3, 256); i++) {
                    energy += audioData[i] * audioData[i];
                }
                energy /= Math.min(audioData.length * 0.3, 256);
                
                this.beatDetector.history.push(energy);
                if (this.beatDetector.history.length > 30) {
                    this.beatDetector.history.shift();
                }
                
                // Calculate average energy
                const avgEnergy = this.beatDetector.history.reduce((sum, e) => sum + e, 0) / this.beatDetector.history.length;
                
                // Beat detection
                const now = performance.now();
                const timeSinceLastBeat = now - this.beatDetector.lastBeat;
                const isBeat = energy > avgEnergy * 1.3 && timeSinceLastBeat > 300; // Min 300ms between beats
                
                if (isBeat) {
                    this.beatDetector.lastBeat = now;
                    return true;
                }
                return false;
            }

            analyzeSpectrum(audioData) {
                if (!audioData) return;
                
                const bandsPerGroup = Math.floor(audioData.length / this.spectrumAnalyzer.frequencyBands);
                
                for (let i = 0; i < this.spectrumAnalyzer.frequencyBands; i++) {
                    let bandSum = 0;
                    const startIdx = i * bandsPerGroup;
                    const endIdx = Math.min(startIdx + bandsPerGroup, audioData.length);
                    
                    for (let j = startIdx; j < endIdx; j++) {
                        bandSum += audioData[j];
                    }
                    
                    const bandAvg = bandSum / (endIdx - startIdx);
                    const smoothing = this.spectrumAnalyzer.smoothingFactor;
                    this.spectrumAnalyzer.bandData[i] = this.spectrumAnalyzer.bandData[i] * smoothing + bandAvg * (1 - smoothing);
                }
            }

            showError(message) {
                document.getElementById('error-text').textContent = message;
                document.getElementById('error-message').style.display = 'block';
                console.error('Visualizer Error:', message);
            }

            detectGPU() {
                try {
                    const canvas = document.createElement('canvas');
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    if (!gl) {
                        this.performanceLevel = 'low';
                        return 'WebGL Not Supported';
                    }
                    
                    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                    const renderer = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : 'Unknown GPU';
                    
                    if (renderer.includes('Intel') || renderer.includes('Software')) {
                        this.performanceLevel = 'medium';
                    } else if (renderer.includes('NVIDIA') || renderer.includes('AMD') || renderer.includes('Radeon')) {
                        this.performanceLevel = 'high';
                    }
                    
                    document.getElementById('gpu-info').textContent = renderer.substring(0, 20) + '...';
                    document.getElementById('quality-level').textContent = this.performanceLevel.charAt(0).toUpperCase() + this.performanceLevel.slice(1);
                    
                    return renderer;
                } catch (e) {
                    this.performanceLevel = 'low';
                    return 'Unknown';
                }
            }

            init() {
                try {
                    this.detectGPU();
                    this.setupThreeJS();
                    this.setupEventListeners();
                    this.updateBackground();
                    this.updateControlVisibility();
                    this.animate();
                    this.showWelcomeMessage();
                } catch (error) {
                    this.showError('Failed to initialize: ' + error.message);
                }
            }

            showWelcomeMessage() {
                setTimeout(() => {
                    document.getElementById('audio-status').innerHTML = 
                        '<span class="pulse">🎵 Ready! Click Start Microphone 🎤</span>';
                }, 1000);
            }

            setupThreeJS() {
                const canvas = document.getElementById('webgl-canvas');
                
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (!gl) {
                    this.showError('WebGL is not supported on this device. Please use a modern browser.');
                    this.isWebGLSupported = false;
                    return;
                }

                this.scene = new THREE.Scene();
                
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 0, 8);

                try {
                    this.renderer = new THREE.WebGLRenderer({ 
                        canvas: canvas,
                        antialias: this.performanceLevel === 'high', 
                        alpha: false,
                        powerPreference: "high-performance",
                        precision: "mediump"
                    });
                    
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    this.renderer.setClearColor(0x000000, 1);
                    
                    const pixelRatio = this.performanceLevel === 'high' ? 
                        Math.min(window.devicePixelRatio, 2) : 1;
                    this.renderer.setPixelRatio(pixelRatio);
                    
                } catch (error) {
                    this.showError('Failed to create WebGL renderer: ' + error.message);
                    return;
                }

                this.applyModeDefaults('fractal');
                this.switchVisualizer('fractal');

                window.addEventListener('resize', () => this.onWindowResize());
            }

            updateControlVisibility() {
                const currentMode = this.settings.visualizerMode;
                const relevantControls = this.modeControls[currentMode] || [];
                
                const allControls = ['zoom', 'contrast', 'orbsize', 'radius', 'colorshift', 'center', 'sides', 'rotation', 'warp', 'maxiter', 'flow', 'complexity', 'distortion', 'kaleidoscope', 'morphing', 'fractal'];
                allControls.forEach(control => {
                    const group = document.getElementById(`${control}-group`);
                    if (group) {
                        group.classList.add('hidden');
                    }
                });
                
                relevantControls.forEach(control => {
                    const group = document.getElementById(`${control}-group`);
                    if (group) {
                        group.classList.remove('hidden');
                    }
                });
            }

            applyModeDefaults(mode) {
                const defaults = this.modeDefaults[mode];
                if (!defaults) return;

                Object.keys(defaults).forEach(key => {
                    this.settings[key] = defaults[key];
                });

                Object.keys(defaults).forEach(key => {
                    const control = document.getElementById(key);
                    const valueSpan = document.getElementById(`${key}-value`);
                    
                    if (control && control.type === 'range') {
                        control.value = defaults[key];
                        if (valueSpan) {
                            valueSpan.textContent = defaults[key];
                        }
                    }
                });
            }

            setupEventListeners() {
                document.getElementById('start-capture').addEventListener('click', () => {
                    if (this.isCapturing) {
                        this.stopAudioCapture();
                    } else {
                        this.startAudioCapture();
                    }
                });

                document.getElementById('visualizer-mode').addEventListener('change', (e) => {
                    const newMode = e.target.value;
                    this.settings.visualizerMode = newMode;
                    
                    this.applyModeDefaults(newMode);
                    this.updateControlVisibility();
                    
                    this.switchVisualizer(newMode);
                    document.getElementById('current-mode').textContent = e.target.options[e.target.selectedIndex].text.split(' ').slice(1).join(' ');
                });

                document.getElementById('color-theme').addEventListener('change', (e) => {
                    this.settings.colorTheme = e.target.value;
                    if (this.currentVisualizer && this.currentVisualizer.updateColors) {
                        this.currentVisualizer.updateColors(this.colorThemes[e.target.value]);
                    }
                });

                const controls = ['sensitivity', 'speed', 'intensity', 'zoom', 'contrast', 'orbsize', 'radius', 'colorshift', 'center', 'sides', 'rotation', 'warp', 'maxiter', 'flow', 'complexity', 'distortion', 'kaleidoscope', 'morphing', 'fractal'];
                controls.forEach(control => {
                    const element = document.getElementById(control);
                    if (element) {
                        element.addEventListener('input', (e) => {
                            this.settings[control] = parseFloat(e.target.value);
                            const valueElement = document.getElementById(`${control}-value`);
                            if (valueElement) {
                                valueElement.textContent = e.target.value;
                            }
                        });
                    }
                });

                document.getElementById('reset-controls').addEventListener('click', () => {
                    this.applyModeDefaults(this.settings.visualizerMode);
                });

                document.getElementById('background-mode').addEventListener('change', (e) => {
                    this.settings.backgroundMode = e.target.value;
                    this.updateBackground();
                });

                document.getElementById('fullscreen-btn').addEventListener('click', () => {
                    this.toggleFullscreen();
                });

                document.addEventListener('keydown', (e) => {
                    switch(e.code) {
                        case 'Space':
                            e.preventDefault();
                            if (this.isCapturing) {
                                this.stopAudioCapture();
                            } else {
                                this.startAudioCapture();
                            }
                            break;
                        case 'F11':
                            e.preventDefault();
                            this.toggleFullscreen();
                            break;
                        case 'KeyH':
                            e.preventDefault();
                            this.toggleControls();
                            break;
                        case 'Digit1':
                        case 'Digit2':
                        case 'Digit3':
                        case 'Digit4':
                        case 'Digit5':
                        case 'Digit6':
                        case 'Digit7':
                            e.preventDefault();
                            const modes = ['fractal', 'neural', 'tunnel', 'cosmic-spheres', 'psychedelic', 'dmt'];
                            const modeIndex = parseInt(e.code.slice(-1)) - 1;
                            if (modes[modeIndex]) {
                                const newMode = modes[modeIndex];
                                document.getElementById('visualizer-mode').value = newMode;
                                this.settings.visualizerMode = newMode;
                                this.applyModeDefaults(newMode);
                                this.updateControlVisibility();
                                this.switchVisualizer(newMode);
                                document.getElementById('current-mode').textContent = 
                                    document.getElementById('visualizer-mode').options[modeIndex].text.split(' ').slice(1).join(' ');
                            }
                            break;
                    }
                });
            }

            toggleControls() {
                const controls = document.getElementById('controls');
                this.controlsVisible = !this.controlsVisible;
                controls.style.display = this.controlsVisible ? 'block' : 'none';
            }

            async startAudioCapture() {
                try {
                    document.getElementById('audio-status').textContent = 'Requesting microphone access...';
                    
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: 44100
                        } 
                    });

                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = 4096;
                    this.analyser.smoothingTimeConstant = 0.8;

                    this.source = this.audioContext.createMediaStreamSource(stream);
                    this.source.connect(this.analyser);

                    this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                    
                    this.isCapturing = true;
                    document.getElementById('audio-status').innerHTML = '🎵 <span class="pulse">Live! Play some music!</span>';
                    document.getElementById('start-capture').textContent = '🛑 Stop Capture';
                    document.getElementById('start-capture').classList.add('active');

                } catch (error) {
                    console.error('Error accessing microphone:', error);
                    document.getElementById('audio-status').textContent = '❌ Microphone access denied';
                }
            }

            stopAudioCapture() {
                if (this.source) this.source.disconnect();
                if (this.audioContext) this.audioContext.close();
                
                this.isCapturing = false;
                document.getElementById('audio-status').textContent = 'Click Start Microphone to begin';
                document.getElementById('start-capture').textContent = '🎤 Start Microphone';
                document.getElementById('start-capture').classList.remove('active');
            }

            toggleFullscreen() {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(err => {
                        console.log('Error attempting to enable fullscreen:', err);
                    });
                } else {
                    document.exitFullscreen();
                }
            }

            analyzeAudio(audioData) {
                if (!audioData) return this.audioAnalysis;
                
                // Enhanced spectrum analysis
                this.analyzeSpectrum(audioData);
                
                const bufferLength = audioData.length;
                const bassEnd = Math.floor(bufferLength * 0.12);
                const midEnd = Math.floor(bufferLength * 0.45);
                const trebleStart = Math.floor(bufferLength * 0.65);
                
                let bassSum = 0, midSum = 0, trebleSum = 0, peak = 0, average = 0;
                
                // Enhanced frequency analysis with better separation
                for (let i = 0; i < bufferLength; i++) {
                    const value = audioData[i];
                    average += value;
                    peak = Math.max(peak, value);
                    
                    if (i < bassEnd) {
                        // Weight bass frequencies more heavily
                        bassSum += value * (i < bassEnd * 0.5 ? 2.0 : 1.0);
                    } else if (i < midEnd) {
                        midSum += value;
                    } else if (i >= trebleStart) {
                        // Emphasize higher treble frequencies
                        trebleSum += value * (i > trebleStart + (bufferLength - trebleStart) * 0.5 ? 1.5 : 1.0);
                    }
                }
                
                this.audioAnalysis.bass = Math.min((bassSum / (bassEnd * 1.5)) / 255, 1.0);
                this.audioAnalysis.mid = Math.min((midSum / (midEnd - bassEnd)) / 255, 1.0);
                this.audioAnalysis.treble = Math.min((trebleSum / (bufferLength - trebleStart * 0.8)) / 255, 1.0);
                this.audioAnalysis.peak = peak / 255;
                this.audioAnalysis.average = (average / bufferLength) / 255;
                
                // Beat detection
                const isBeat = this.detectBeats(audioData, this.audioAnalysis);
                this.audioAnalysis.beat = isBeat;
                
                // Calculate RMS for better energy detection
                let rms = 0;
                for (let i = 0; i < bufferLength; i++) {
                    rms += audioData[i] * audioData[i];
                }
                this.audioAnalysis.rms = Math.sqrt(rms / bufferLength) / 255;
                
                // Store history for advanced analysis
                this.audioAnalysis.history.push({
                    bass: this.audioAnalysis.bass,
                    mid: this.audioAnalysis.mid,
                    treble: this.audioAnalysis.treble,
                    peak: this.audioAnalysis.peak,
                    rms: this.audioAnalysis.rms,
                    beat: isBeat,
                    time: performance.now()
                });
                
                // Keep only recent history
                if (this.audioAnalysis.history.length > 60) { // 1 second at 60fps
                    this.audioAnalysis.history.shift();
                }
                
                // Calculate energy trends
                if (this.audioAnalysis.history.length > 10) {
                    const recent = this.audioAnalysis.history.slice(-10);
                    const older = this.audioAnalysis.history.slice(-20, -10);
                    
                    const recentAvg = recent.reduce((sum, h) => sum + h.rms, 0) / recent.length;
                    const olderAvg = older.length > 0 ? older.reduce((sum, h) => sum + h.rms, 0) / older.length : recentAvg;
                    
                    this.audioAnalysis.energyTrend = recentAvg - olderAvg;
                }
                
                return this.audioAnalysis;
            }

            switchVisualizer(mode) {
                if (!this.isWebGLSupported) return;

                if (this.currentVisualizer && this.currentVisualizer.dispose) {
                    this.currentVisualizer.dispose();
                }

                // Clear scene more thoroughly
                while(this.scene.children.length > 0) {
                    const child = this.scene.children[0];
                    this.scene.remove(child);
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => mat.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                }
                
                // Clear fog
                this.scene.fog = null;

                const colors = this.colorThemes[this.settings.colorTheme];

                try {
                    switch(mode) {
                        case 'fractal':
                            this.currentVisualizer = new EnhancedFractalVisualizer(this.scene, colors, this.performanceLevel);
                            this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                            this.camera.position.set(0, 0, 8);
                            break;
                        case 'neural':
                            this.currentVisualizer = new EnhancedNeuralVisualizer(this.scene, colors, this.performanceLevel);
                            this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                            this.camera.position.set(0, 0, 8);
                            break;
                        case 'tunnel':
                            this.currentVisualizer = new EnhancedTunnelVisualizer(this.scene, colors, this.performanceLevel);
                            this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                            this.camera.position.set(0, 0, 8);
                            break;
                        case 'cosmic-spheres':
                            this.currentVisualizer = new CosmicSpheresVisualizer(this.scene, colors, this.performanceLevel);
                            this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                            this.camera.position.set(0, 0, 8);
                            break;
                        case 'psychedelic':
                            this.currentVisualizer = new FullscreenPsychedelicVisualizer(this.scene, colors, this.performanceLevel);
                            this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
                            this.camera.position.z = 1;
                            break;
                        case 'dmt':
                            this.currentVisualizer = new FullscreenDMTVisualizer(this.scene, colors, this.performanceLevel);
                            this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
                            this.camera.position.z = 1;
                            break;
                    }
                } catch (error) {
                    this.showError('Failed to create visualizer: ' + error.message);
                    this.currentVisualizer = new EnhancedFractalVisualizer(this.scene, colors, 'low');
                }
            }

            updateBackground() {
                const body = document.body;
                body.className = this.settings.backgroundMode;
                
                // Also update the renderer clear color based on background
                if (this.renderer) {
                    switch(this.settings.backgroundMode) {
                        case 'dark':
                            this.renderer.setClearColor(0x000000, 1);
                            break;
                        case 'matrix':
                            this.renderer.setClearColor(0x001100, 1);
                            break;
                        case 'cosmic':
                            this.renderer.setClearColor(0x120458, 1);
                            break;
                        case 'stars':
                            this.renderer.setClearColor(0x000000, 1);
                            break;
                        default:
                            this.renderer.setClearColor(0x0f0f23, 1);
                            break;
                    }
                }
            }

            animate() {
                if (!this.isWebGLSupported) return;

                this.animationId = requestAnimationFrame(() => this.animate());

                const frameStart = performance.now();

                // Dynamic performance adjustment
                const targetFPS = 60;
                const currentFPS = 1000 / (frameStart - this.lastFpsTime);
                if (this.fpsCounter % 60 === 0) { // Adjust every 60 frames
                    if (currentFPS < 30 && this.performanceLevel === 'high') {
                        this.performanceLevel = 'medium';
                        console.log('Performance adjusted to medium');
                    } else if (currentFPS < 20 && this.performanceLevel === 'medium') {
                        this.performanceLevel = 'low';
                        console.log('Performance adjusted to low');
                    } else if (currentFPS > 50 && this.performanceLevel === 'low') {
                        this.performanceLevel = 'medium';
                        console.log('Performance adjusted to medium');
                    } else if (currentFPS > 55 && this.performanceLevel === 'medium') {
                        this.performanceLevel = 'high';
                        console.log('Performance adjusted to high');
                    }
                }

                // FPS tracking
                this.fpsCounter++;
                if (frameStart - this.lastFpsTime >= 1000) {
                    document.getElementById('fps-counter').textContent = Math.round(this.fpsCounter);
                    this.fpsCounter = 0;
                    this.lastFpsTime = frameStart;
                }

                // Enhanced audio analysis
                let audioData = null;
                if (this.isCapturing && this.analyser) {
                    this.analyser.getByteFrequencyData(this.dataArray);
                    audioData = this.dataArray;
                }

                const analysis = this.analyzeAudio(audioData);

                // Beat-reactive background flash
                if (analysis.beat && this.settings.backgroundMode !== 'dark') {
                    const flash = Math.min(analysis.rms * 0.5, 0.3);
                    document.body.style.filter = `brightness(${1 + flash})`;
                    setTimeout(() => {
                        document.body.style.filter = 'brightness(1)';
                    }, 100);
                }

                // Dynamic camera effects for certain modes
                if (this.camera && this.currentVisualizer) {
                    const visualizerMode = this.settings.visualizerMode;
                    
                    if (visualizerMode === 'edm-lightshow' && analysis.beat) {
                        // Camera shake on beat
                        const shakeIntensity = analysis.rms * 0.2;
                        this.camera.position.x += (Math.random() - 0.5) * shakeIntensity;
                        this.camera.position.y += (Math.random() - 0.5) * shakeIntensity;
                    } else if (visualizerMode === 'tunnel') {
                        // Slight camera movement in tunnel
                        const sway = Math.sin(frameStart * 0.001) * analysis.average * 0.5;
                        this.camera.position.x = sway + this.settings.center * 2;
                        this.camera.position.y = Math.cos(frameStart * 0.0008) * analysis.mid * 0.3;
                    } else if (visualizerMode === 'dmt' || visualizerMode === 'psychedelic') {
                        // Subtle zoom pulsing for shader modes
                        if (this.camera instanceof THREE.OrthographicCamera) {
                            const zoomPulse = 1 + analysis.rms * 0.1;
                            this.camera.zoom = zoomPulse;
                            this.camera.updateProjectionMatrix();
                        }
                    }
                }

                // Update visualizer with enhanced analysis
                if (this.currentVisualizer && this.currentVisualizer.update) {
                    // Add spectrum data to analysis for advanced visualizers
                    analysis.spectrum = this.spectrumAnalyzer.bandData;
                    analysis.energyTrend = this.audioAnalysis.energyTrend || 0;
                    
                    this.currentVisualizer.update(audioData, this.settings, analysis);
                }

                // Adaptive rendering quality
                if (this.renderer) {
                    // Reduce pixel ratio if performance is poor
                    const targetPixelRatio = this.performanceLevel === 'high' ? 
                        Math.min(window.devicePixelRatio, 2) : 
                        this.performanceLevel === 'medium' ? 1.5 : 1;
                    
                    if (Math.abs(this.renderer.getPixelRatio() - targetPixelRatio) > 0.1) {
                        this.renderer.setPixelRatio(targetPixelRatio);
                    }
                    
                    this.renderer.render(this.scene, this.camera);
                }

                // Update performance indicator
                const frameEnd = performance.now();
                const frameTime = frameEnd - frameStart;
                if (frameTime > 20) { // Frame took longer than 50fps
                    document.getElementById('quality-level').style.color = '#ff6666';
                } else if (frameTime > 16.67) { // Frame took longer than 60fps
                    document.getElementById('quality-level').style.color = '#ffaa66';
                } else {
                    document.getElementById('quality-level').style.color = '#66ff66';
                }
            }

            onWindowResize() {
                if (!this.isWebGLSupported) return;

                if (this.camera instanceof THREE.PerspectiveCamera) {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                }
                
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                
                if (this.currentVisualizer && this.currentVisualizer.plane && this.currentVisualizer.plane.material.uniforms) {
                    const uniforms = this.currentVisualizer.plane.material.uniforms;
                    if (uniforms.u_res) {
                        uniforms.u_res.value.set(window.innerWidth, window.innerHeight);
                    }
                }
            }
        }

        // Enhanced Fractal Visualizer
        class EnhancedFractalVisualizer {
            constructor(scene, colors, performance) {
                this.scene = scene;
                this.colors = colors;
                this.performance = performance;
                this.fractals = [];
                this.time = 0;
                this.createFractals();
            }

            createFractals() {
                const count = this.performance === 'high' ? 8 : this.performance === 'medium' ? 6 : 4;
                
                for (let level = 0; level < count; level++) {
                    const size = 2.5 - level * 0.3;
                    const detail = this.performance === 'high' ? level + 1 : 1;
                    const geometry = new THREE.IcosahedronGeometry(size, detail);
                    
                    const material = new THREE.MeshPhongMaterial({
                        color: this.colors.primary,
                        emissive: this.colors.primary,
                        emissiveIntensity: 0.4,
                        transparent: true,
                        opacity: 0.8 - level * 0.1,
                        wireframe: level % 2 === 1
                    });

                    const fractal = new THREE.Mesh(geometry, material);
                    fractal.userData = { level: level, baseSize: size };
                    this.fractals.push(fractal);
                    this.scene.add(fractal);
                }

                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);

                const pointLight = new THREE.PointLight(this.colors.accent, 3, 50);
                pointLight.position.set(0, 0, 10);
                this.scene.add(pointLight);
                this.pointLight = pointLight;
            }

            update(audioData, settings, analysis) {
                if (!audioData) {
                    const time = Date.now() * 0.001;
                    audioData = new Uint8Array(2048);
                    for (let i = 0; i < audioData.length; i++) {
                        audioData[i] = Math.sin(time + i * 0.02) * 60 + 120;
                    }
                }

                this.time += 0.016 * settings.speed;

                this.fractals.forEach((fractal, index) => {
                    const level = fractal.userData.level;
                    
                    let amplitude;
                    if (level < 2) amplitude = analysis.bass;
                    else if (level < 4) amplitude = analysis.mid;
                    else amplitude = analysis.treble;

                    const scale = (1 + amplitude * (4 + level * 0.5) * settings.intensity) * settings.zoom;
                    fractal.scale.setScalar(scale);
                    
                    const rotSpeed = settings.rotation * settings.speed;
                    fractal.rotation.x += (0.02 + amplitude * 0.15) * rotSpeed;
                    fractal.rotation.y += (0.025 + amplitude * 0.12) * rotSpeed;
                    fractal.rotation.z += (0.015 + amplitude * 0.08) * rotSpeed;
                    
                    fractal.material.emissiveIntensity = (0.4 + amplitude * 4) * settings.contrast;
                    
                    const orbSize = settings.orbsize;
                    fractal.position.x = Math.sin(this.time + level) * amplitude * 4 * orbSize + settings.center;
                    fractal.position.y = Math.cos(this.time * 1.3 + level) * amplitude * 4 * orbSize;
                    fractal.position.z = Math.sin(this.time * 0.7 + level) * amplitude * 3 * orbSize;
                    
                    const hue = (amplitude * settings.colorshift + analysis.peak * 0.5 + this.time * 0.1) % 1;
                    fractal.material.color.setHSL(hue, 0.9, 0.6 + amplitude * 0.3);
                    fractal.material.emissive.setHSL(hue, 1.0, 0.4 + amplitude * 0.4);
                });
            }

            updateColors(colors) {
                this.colors = colors;
                this.fractals.forEach(fractal => {
                    fractal.material.color.setHex(colors.primary);
                    fractal.material.emissive.setHex(colors.primary);
                });
                if (this.pointLight) {
                    this.pointLight.color.setHex(colors.accent);
                }
            }

            dispose() {
                this.fractals.forEach(fractal => {
                    this.scene.remove(fractal);
                    fractal.geometry.dispose();
                    fractal.material.dispose();
                });
                this.fractals = [];
            }
        }

        // Ultra-Enhanced Neural Network Visualizer
        class EnhancedNeuralVisualizer {
            constructor(scene, colors, performance) {
                this.scene = scene;
                this.colors = colors;
                this.performance = performance;
                this.nodes = [];
                this.connections = [];
                this.dataFlows = [];
                this.neuralPulses = [];
                this.time = 0;
                this.createAdvancedNetwork();
            }

            createAdvancedNetwork() {
                // More complex network architecture for stunning visuals
                const layers = this.performance === 'high' ? [12, 16, 20, 24, 20, 16, 12] :
                              this.performance === 'medium' ? [10, 14, 18, 20, 18, 14, 10] : [8, 12, 16, 18, 16, 12, 8];
                const layerSpacing = 2.8;
                let nodeId = 0;

                // Create nodes with enhanced visual complexity
                layers.forEach((nodeCount, layerIndex) => {
                    const startY = -(nodeCount - 1) * 0.5;
                    const xPos = (layerIndex - (layers.length - 1) / 2) * layerSpacing;
                    
                    for (let i = 0; i < nodeCount; i++) {
                        // Enhanced node geometry with more detail
                        const geometry = new THREE.IcosahedronGeometry(0.08, 1);
                        const material = new THREE.MeshBasicMaterial({
                            color: this.colors.primary,
                            transparent: true,
                            opacity: 0.9,
                            blending: THREE.AdditiveBlending
                        });

                        const node = new THREE.Mesh(geometry, material);
                        node.position.set(xPos, startY + i * 1.0, 0);
                        
                        // Add glow ring around each node
                        const ringGeometry = new THREE.RingGeometry(0.12, 0.16, 8);
                        const ringMaterial = new THREE.MeshBasicMaterial({
                            color: this.colors.accent,
                            transparent: true,
                            opacity: 0.6,
                            side: THREE.DoubleSide,
                            blending: THREE.AdditiveBlending
                        });
                        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                        ring.position.copy(node.position);
                        ring.lookAt(0, 0, 1);
                        
                        node.userData = {
                            id: nodeId++,
                            layer: layerIndex,
                            activation: 0,
                            baseSize: 0.08,
                            basePosition: new THREE.Vector3(xPos, startY + i * 1.0, 0),
                            pulseOffset: Math.random() * Math.PI * 2,
                            ring: ring,
                            nodeIndex: i
                        };
                        
                        this.nodes.push(node);
                        this.scene.add(node);
                        this.scene.add(ring);
                    }
                });

                // Create comprehensive connections ensuring ALL layers are connected
                for (let l = 0; l < layers.length - 1; l++) {
                    const currentLayer = this.nodes.filter(n => n.userData.layer === l);
                    const nextLayer = this.nodes.filter(n => n.userData.layer === l + 1);
                    
                    console.log(`Connecting layer ${l} (${currentLayer.length} nodes) to layer ${l+1} (${nextLayer.length} nodes)`);
                    
                    currentLayer.forEach((node1, i) => {
                        nextLayer.forEach((node2, j) => {
                            // Ensure good coverage across all layers
                            let shouldConnect = false;
                            
                            if (this.performance === 'high') {
                                // High performance: Connect 75% of possible connections
                                shouldConnect = (i + j + l) % 4 !== 3;
                            } else if (this.performance === 'medium') {
                                // Medium performance: Connect 60% of possible connections
                                shouldConnect = (i + j + l) % 5 !== 4;
                            } else {
                                // Low performance: Connect 50% but ensure good distribution
                                shouldConnect = (i + j + l) % 2 === 0 || Math.abs(i - j) <= 1;
                            }
                            
                            if (shouldConnect) {
                                // Create connection line
                                const geometry = new THREE.BufferGeometry();
                                const positions = new Float32Array([
                                    node1.position.x, node1.position.y, node1.position.z,
                                    node2.position.x, node2.position.y, node2.position.z
                                ]);
                                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                                
                                const material = new THREE.LineBasicMaterial({
                                    color: this.colors.secondary,
                                    transparent: true,
                                    opacity: 0.4, // Increased base opacity
                                    blending: THREE.AdditiveBlending
                                });
                                
                                const line = new THREE.Line(geometry, material);
                                line.userData = {
                                    node1,
                                    node2,
                                    strength: 0.5 + Math.random() * 0.5,
                                    positions: positions,
                                    layerConnection: l,
                                    baseOpacity: 0.4,
                                    fromLayer: l,
                                    toLayer: l + 1
                                };
                                
                                this.connections.push(line);
                                this.scene.add(line);
                                
                                // Add data flow particles for visual feedback
                                if (this.performance !== 'low' && Math.random() < 0.4) {
                                    const flowGeometry = new THREE.SphereGeometry(0.025, 4, 4);
                                    const flowMaterial = new THREE.MeshBasicMaterial({
                                        color: this.colors.accent,
                                        transparent: true,
                                        opacity: 0.9,
                                        blending: THREE.AdditiveBlending
                                    });
                                    
                                    const flowParticle = new THREE.Mesh(flowGeometry, flowMaterial);
                                    flowParticle.userData = {
                                        connection: line,
                                        progress: Math.random(),
                                        speed: 0.015 + Math.random() * 0.025,
                                        active: false,
                                        fromLayer: l,
                                        toLayer: l + 1
                                    };
                                    
                                    this.dataFlows.push(flowParticle);
                                    this.scene.add(flowParticle);
                                }
                            }
                        });
                    });
                }

                // Add some long-range connections to ensure network spans fully
                for (let l = 0; l < layers.length - 2; l++) {
                    const currentLayer = this.nodes.filter(n => n.userData.layer === l);
                    const targetLayer = this.nodes.filter(n => n.userData.layer === l + 2);
                    
                    // Add strategic long-range connections
                    currentLayer.forEach((node1, i) => {
                        if (i < targetLayer.length && Math.random() < 0.3) {
                            const node2 = targetLayer[i];
                            
                            const geometry = new THREE.BufferGeometry();
                            const positions = new Float32Array([
                                node1.position.x, node1.position.y, node1.position.z,
                                node2.position.x, node2.position.y, node2.position.z
                            ]);
                            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                            
                            const material = new THREE.LineBasicMaterial({
                                color: this.colors.accent,
                                transparent: true,
                                opacity: 0.25,
                                blending: THREE.AdditiveBlending
                            });
                            
                            const line = new THREE.Line(geometry, material);
                            line.userData = {
                                node1,
                                node2,
                                strength: Math.random() * 0.7,
                                positions: positions,
                                layerConnection: -1, // Mark as long-range
                                baseOpacity: 0.25,
                                fromLayer: l,
                                toLayer: l + 2
                            };
                            
                            this.connections.push(line);
                            this.scene.add(line);
                        }
                    });
                }

                console.log(`Created ${this.connections.length} total connections across ${layers.length} layers`);

                // Add neural pulse effects
                if (this.performance === 'high') {
                    for (let i = 0; i < 20; i++) {
                        const pulseGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                        const pulseMaterial = new THREE.MeshBasicMaterial({
                            color: this.colors.primary,
                            transparent: true,
                            opacity: 0,
                            blending: THREE.AdditiveBlending
                        });
                        
                        const pulse = new THREE.Mesh(pulseGeometry, pulseMaterial);
                        pulse.userData = {
                            active: false,
                            startTime: 0,
                            duration: 1000, // ms
                            startNode: null,
                            targetNode: null
                        };
                        
                        this.neuralPulses.push(pulse);
                        this.scene.add(pulse);
                    }
                }

                // Enhanced lighting for neural network
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                
                // Multiple dynamic point lights
                for (let i = 0; i < 3; i++) {
                    const pointLight = new THREE.PointLight(this.colors.primary, 0.8, 25);
                    pointLight.position.set(
                        (i - 1) * 6,
                        Math.sin(i * 2) * 4,
                        10
                    );
                    pointLight.userData = {
                        index: i,
                        baseIntensity: 0.8
                    };
                    this.scene.add(pointLight);
                    if (i === 0) this.pointLight = pointLight;
                }
            }

            update(audioData, settings, analysis) {
                if (!audioData) {
                    const time = Date.now() * 0.001;
                    audioData = new Uint8Array(1024);
                    for (let i = 0; i < audioData.length; i++) {
                        audioData[i] = Math.sin(time + i * 0.02) * 80 + 140;
                    }
                }

                this.time += 0.016 * settings.speed;
                const nodeCount = this.nodes.length;
                const audioLength = audioData?.length || 1024;
                
                // Static neural network with audio flow visualization
                for (let i = 0; i < nodeCount; i++) {
                    const node = this.nodes[i];
                    const layer = node.userData.layer;
                    
                    // Map different layers to different frequency ranges for realistic neural flow
                    let freqIndex;
                    const layerCount = Math.max(...this.nodes.map(n => n.userData.layer)) + 1;
                    if (layer === 0) {
                        // Input layer - bass frequencies
                        freqIndex = Math.floor((node.userData.nodeIndex / 12) * (audioLength * 0.25));
                    } else if (layer === layerCount - 1) {
                        // Output layer - treble frequencies
                        freqIndex = Math.floor(audioLength * 0.75 + (node.userData.nodeIndex / 12) * (audioLength * 0.25));
                    } else {
                        // Hidden layers - mid frequencies
                        const layerRatio = (layer - 1) / Math.max(layerCount - 3, 1);
                        freqIndex = Math.floor(audioLength * 0.25 + layerRatio * (audioLength * 0.5));
                    }
                    
                    const rawActivation = audioData ? (audioData[freqIndex] / 255) : 0.2;
                    const activation = rawActivation * settings.sensitivity;
                    node.userData.activation = activation;
                    
                    // Subtle scaling - no dramatic pulsing
                    const baseScale = 1.0;
                    const audioScale = baseScale + activation * settings.intensity * 0.8;
                    node.scale.setScalar(Math.min(audioScale * settings.zoom, 2.0));
                    
                    // Static color with subtle brightness changes
                    const baseHue = layer * 0.15; // Different hue per layer
                    const hue = (baseHue + activation * settings.colorshift * 0.3) % 1;
                    const saturation = 0.8;
                    const lightness = 0.4 + activation * 0.4; // Brightness responds to audio
                    node.material.color.setHSL(hue, saturation, lightness);
                    node.material.opacity = (0.9 + activation * 0.1) * settings.contrast;
                    
                    // Ring effects - subtle
                    const ring = node.userData.ring;
                    ring.scale.setScalar(audioScale * 1.2 * settings.zoom);
                    ring.material.color.setHSL(hue, 0.7, 0.5 + activation * 0.3);
                    ring.material.opacity = (0.3 + activation * 0.4) * settings.contrast;
                    
                    // Keep nodes in static positions
                    node.position.copy(node.userData.basePosition);
                }

                // Static connections that only brighten with audio - NO PULSING
                this.connections.forEach((connection, index) => {
                    const node1 = connection.userData.node1;
                    const node2 = connection.userData.node2;
                    const fromLayer = connection.userData.fromLayer;
                    const toLayer = connection.userData.toLayer;
                    
                    // Calculate activation based on both connected nodes
                    const node1Activation = node1.userData.activation || 0;
                    const node2Activation = node2.userData.activation || 0;
                    const avgActivation = (node1Activation + node2Activation) * 0.5;
                    
                    // Static base opacity - no time-based changes
                    const layerDepth = Math.max(fromLayer || 0, toLayer || 0);
                    const baseOpacity = 0.3 + (layerDepth / 7) * 0.1; // Deeper layers slightly more visible
                    
                    // Audio boost calculation - ONLY audio, no time component
                    const layerMultiplier = (fromLayer === 0 || toLayer === 6) ? 1.5 : 1.0;
                    const audioBoost = avgActivation * settings.intensity * 1.8 * layerMultiplier;
                    const finalOpacity = Math.min(baseOpacity + audioBoost, 1.0) * settings.contrast;
                    
                    connection.material.opacity = finalOpacity;
                    
                    // Static color with ONLY audio influence - removed time component
                    const layerHue = ((fromLayer || 0) + (toLayer || 0)) * 0.08;
                    const audioHue = avgActivation * settings.colorshift * 0.4;
                    const hue = (layerHue + audioHue) % 1; // NO TIME COMPONENT
                    const saturation = 0.8;
                    const lightness = 0.5 + avgActivation * 0.4; // Only audio affects brightness
                    connection.material.color.setHSL(hue, saturation, lightness);
                    
                    // Update positions to ensure connections span properly
                    const positions = connection.userData.positions;
                    positions[0] = node1.position.x;
                    positions[1] = node1.position.y;
                    positions[2] = node1.position.z;
                    positions[3] = node2.position.x;
                    positions[4] = node2.position.y;
                    positions[5] = node2.position.z;
                    connection.geometry.attributes.position.needsUpdate = true;
                });

                // Enhanced data flow particles - these show the audio "traveling" through the network
                this.dataFlows.forEach((flow, index) => {
                    const connection = flow.userData.connection;
                    const node1 = connection.userData.node1;
                    const node2 = connection.userData.node2;
                    const avgActivation = (node1.userData.activation + node2.userData.activation) * 0.5;
                    
                    // Only activate flow when there's significant audio activity
                    flow.userData.active = avgActivation > 0.4;
                    
                    if (flow.userData.active) {
                        // Flow speed based on audio intensity
                        const flowSpeed = flow.userData.speed * settings.speed * (1 + avgActivation * 2);
                        flow.userData.progress += flowSpeed;
                        if (flow.userData.progress > 1) flow.userData.progress = 0;
                        
                        // Move along connection path
                        const t = flow.userData.progress;
                        flow.position.lerpVectors(node1.position, node2.position, t);
                        
                        // Visual effects for data flow
                        const scale = (1.5 + avgActivation * 2) * settings.zoom;
                        flow.scale.setScalar(scale);
                        
                        // Bright, distinct color for data flow
                        const hue = (avgActivation * settings.colorshift + this.time * 0.2 + index * 0.1) % 1;
                        flow.material.color.setHSL(hue, 1.0, 0.9);
                        flow.material.opacity = (0.8 + avgActivation * 0.2) * settings.contrast;
                    } else {
                        flow.material.opacity = 0;
                    }
                });

                // Neural pulse system - only for major audio events
                this.neuralPulses.forEach(pulse => {
                    if (!pulse.userData.active && analysis.peak > 0.7) {
                        // Trigger pulse only on strong audio peaks
                        const highActivityNodes = this.nodes.filter(n => n.userData.activation > 0.6);
                        if (highActivityNodes.length > 1) {
                            pulse.userData.active = true;
                            pulse.userData.startTime = this.time;
                            pulse.userData.startNode = highActivityNodes[0]; // Start from first layer
                            pulse.userData.targetNode = highActivityNodes[highActivityNodes.length - 1]; // End at last layer
                        }
                    }
                    
                    if (pulse.userData.active) {
                        const elapsed = this.time - pulse.userData.startTime;
                        const progress = Math.min(elapsed / (pulse.userData.duration / 1000), 1);
                        
                        if (progress >= 1) {
                            pulse.userData.active = false;
                            pulse.material.opacity = 0;
                        } else {
                            // Animate pulse across the network
                            pulse.position.lerpVectors(
                                pulse.userData.startNode.position,
                                pulse.userData.targetNode.position,
                                progress
                            );
                            
                            // Pulse visual effects
                            const intensity = Math.sin(progress * Math.PI) * (2 + analysis.peak * 3);
                            pulse.scale.setScalar(intensity * settings.zoom);
                            pulse.material.opacity = intensity * 0.9 * settings.contrast;
                            
                            const hue = (progress * 0.5 + this.time * 0.1) % 1;
                            pulse.material.color.setHSL(hue, 1.0, 0.8);
                        }
                    }
                });

                // Static lighting - no movement
                if (this.pointLight) {
                    const lightIntensity = (1.2 + analysis.average * 2) * settings.contrast;
                    this.pointLight.intensity = lightIntensity;
                    
                    const lightHue = (analysis.average * settings.colorshift + this.time * 0.03) % 1;
                    this.pointLight.color.setHSL(lightHue, 0.7, 0.6);
                }
            }

            updateColors(colors) {
                this.colors = colors;
                
                // Update nodes
                this.nodes.forEach(node => {
                    node.material.color.setHex(colors.primary);
                    if (node.userData.ring) {
                        node.userData.ring.material.color.setHex(colors.accent);
                    }
                });
                
                // Update connections
                this.connections.forEach(connection => {
                    connection.material.color.setHex(colors.secondary);
                });
                
                // Update data flows
                this.dataFlows.forEach(flow => {
                    flow.material.color.setHex(colors.accent);
                });
                
                // Update neural pulses
                this.neuralPulses.forEach(pulse => {
                    pulse.material.color.setHex(colors.primary);
                });
                
                if (this.pointLight) {
                    this.pointLight.color.setHex(colors.primary);
                }
            }

            dispose() {
                // Dispose nodes and their rings
                this.nodes.forEach(node => {
                    this.scene.remove(node);
                    node.geometry.dispose();
                    node.material.dispose();
                    
                    if (node.userData.ring) {
                        this.scene.remove(node.userData.ring);
                        node.userData.ring.geometry.dispose();
                        node.userData.ring.material.dispose();
                    }
                });
                
                // Dispose connections
                this.connections.forEach(connection => {
                    this.scene.remove(connection);
                    connection.geometry.dispose();
                    connection.material.dispose();
                });
                
                // Dispose data flows
                this.dataFlows.forEach(flow => {
                    this.scene.remove(flow);
                    flow.geometry.dispose();
                    flow.material.dispose();
                });
                
                // Dispose neural pulses
                this.neuralPulses.forEach(pulse => {
                    this.scene.remove(pulse);
                    pulse.geometry.dispose();
                    pulse.material.dispose();
                });
                
                this.nodes = [];
                this.connections = [];
                this.dataFlows = [];
                this.neuralPulses = [];
            }
        }


        // Enhanced Endless 3D Tunnel Visualizer
        class EnhancedTunnelVisualizer {
            constructor(scene, colors, performance) {
                this.scene = scene;
                this.colors = colors;
                this.performance = performance;
                this.tunnelWalls = [];
                this.tunnelRings = [];
                this.particles = [];
                this.time = 0;
                this.tunnelPosition = 0;
                this.createEndlessTunnel();
            }

            createEndlessTunnel() {
                const segmentCount = this.performance === 'high' ? 60 : this.performance === 'medium' ? 45 : 30;
                const segmentSpacing = 1.5;
                const tunnelRadius = 4.0;
                const wallSegments = this.performance === 'high' ? 20 : this.performance === 'medium' ? 16 : 12;
                
                // Create continuous tunnel walls without segments that reset
                for (let i = 0; i < segmentCount; i++) {
                    const zPosition = -i * segmentSpacing;
                    
                    // Create tunnel wall ring
                    for (let j = 0; j < wallSegments; j++) {
                        const angle = (j / wallSegments) * Math.PI * 2;
                        
                        // Create individual wall panels for seamless movement
                        const geometry = new THREE.PlaneGeometry(0.8, segmentSpacing * 1.2);
                        const material = new THREE.MeshBasicMaterial({
                            color: this.colors.primary,
                            transparent: true,
                            opacity: 0.7,
                            side: THREE.DoubleSide,
                            blending: THREE.AdditiveBlending
                        });
                        
                        const wallPanel = new THREE.Mesh(geometry, material);
                        const x = Math.cos(angle) * tunnelRadius;
                        const y = Math.sin(angle) * tunnelRadius;
                        
                        wallPanel.position.set(x, y, zPosition);
                        wallPanel.lookAt(x * 2, y * 2, zPosition);
                        
                        wallPanel.userData = {
                            wallIndex: j,
                            angle: angle,
                            baseZ: zPosition,
                            segmentIndex: i,
                            baseOpacity: 0.7
                        };
                        
                        this.tunnelWalls.push(wallPanel);
                        this.scene.add(wallPanel);
                    }
                    
                    // Add wireframe rings for structure
                    const ringGeometry = new THREE.RingGeometry(tunnelRadius * 0.95, tunnelRadius * 1.05, wallSegments);
                    const ringMaterial = new THREE.MeshBasicMaterial({
                        color: this.colors.accent,
                        transparent: true,
                        opacity: 0.4,
                        side: THREE.DoubleSide,
                        wireframe: true,
                        blending: THREE.AdditiveBlending
                    });
                    
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.position.z = zPosition;
                    ring.userData = {
                        baseZ: zPosition,
                        segmentIndex: i
                    };
                    
                    this.tunnelRings.push(ring);
                    this.scene.add(ring);
                }

                // Add flowing particles for motion enhancement
                const particleCount = this.performance === 'high' ? 200 : this.performance === 'medium' ? 150 : 100;
                for (let i = 0; i < particleCount; i++) {
                    const particleGeometry = new THREE.SphereGeometry(0.02, 4, 4);
                    const particleMaterial = new THREE.MeshBasicMaterial({
                        color: this.colors.accent,
                        transparent: true,
                        opacity: 0.8,
                        blending: THREE.AdditiveBlending
                    });
                    
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 2 + Math.random() * 3;
                    
                    particle.position.set(
                        Math.cos(angle) * radius,
                        Math.sin(angle) * radius,
                        -Math.random() * segmentCount * segmentSpacing
                    );
                    
                    particle.userData = {
                        speed: 0.5 + Math.random() * 2,
                        angle: angle,
                        radius: radius,
                        baseZ: particle.position.z
                    };
                    
                    this.particles.push(particle);
                    this.scene.add(particle);
                }

                // Dynamic fog for depth
                this.scene.fog = new THREE.Fog(0x000000, 8, segmentCount * segmentSpacing * 0.7);
                
                // Enhanced lighting setup
                const ambientLight = new THREE.AmbientLight(0x222244, 0.4);
                this.scene.add(ambientLight);
                
                // Multiple moving point lights
                for (let i = 0; i < 3; i++) {
                    const pointLight = new THREE.PointLight(this.colors.primary, 1.5, 12);
                    pointLight.position.set(
                        Math.cos(i * 2.1) * 2,
                        Math.sin(i * 2.1) * 2,
                        5 - i * 3
                    );
                    pointLight.userData = { index: i, baseIntensity: 1.5 };
                    this.scene.add(pointLight);
                    if (i === 0) this.pointLight = pointLight;
                    if (i === 1) this.pointLight2 = pointLight;
                    if (i === 2) this.pointLight3 = pointLight;
                }
            }

            update(audioData, settings, analysis) {
                if (!audioData) {
                    const time = Date.now() * 0.001;
                    audioData = new Uint8Array(1024);
                    for (let i = 0; i < audioData.length; i++) {
                        audioData[i] = Math.sin(time + i * 0.02) * 60 + 120;
                    }
                }

                this.time += 0.016 * settings.speed;
                const tunnelSpeed = (0.8 + analysis.bass * 1.2) * settings.speed;
                this.tunnelPosition += tunnelSpeed * 0.1;

                // Update tunnel walls for truly endless movement
                this.tunnelWalls.forEach((wall, wallIndex) => {
                    const segmentIndex = wall.userData.segmentIndex;
                    const freqIndex = Math.floor((wallIndex / this.tunnelWalls.length) * audioData.length);
                    const amplitude = audioData[freqIndex] / 255;
                    
                    // Continuous Z position movement with proper cycling
                    wall.position.z = wall.userData.baseZ + this.tunnelPosition;
                    
                    // Seamless reset when wall passes camera
                    const segmentCount = this.performance === 'high' ? 60 : this.performance === 'medium' ? 45 : 30;
                    const totalTunnelLength = segmentCount * 1.5;
                    
                    if (wall.position.z > 15) {
                        wall.position.z -= totalTunnelLength;
                        wall.userData.baseZ -= totalTunnelLength;
                    }
                    
                    // Enhanced audio-reactive effects
                    const pulseIntensity = Math.sin(this.time * 4 + wallIndex * 0.3) * 0.3 + 0.7;
                    const audioReactivity = (analysis.bass * 0.4 + analysis.mid * 0.4 + analysis.treble * 0.2);
                    wall.material.opacity = (wall.userData.baseOpacity + audioReactivity * 0.6 * pulseIntensity) * settings.contrast;
                    
                    // Dynamic radius modulation
                    const originalAngle = wall.userData.angle;
                    const radiusVariation = 1 + amplitude * settings.orbsize * 0.6;
                    const tunnelRadius = 4.0 * radiusVariation * settings.zoom;
                    
                    // Add audio-reactive warping
                    const warpAmount = amplitude * settings.intensity * 0.5;
                    const angleOffset = this.time * settings.rotation * 0.15 + Math.sin(this.time * 2 + wallIndex * 0.3) * warpAmount;
                    
                    const x = Math.cos(originalAngle + angleOffset) * tunnelRadius + settings.center * 4;
                    const y = Math.sin(originalAngle + angleOffset) * tunnelRadius;
                    
                    // Add subtle Z-axis movement for depth variation
                    const zOffset = Math.sin(this.time * 1.5 + wallIndex * 0.2) * amplitude * 0.5;
                    
                    wall.position.x = x;
                    wall.position.y = y;
                    wall.position.z += zOffset * 0.1;
                    
                    // Advanced color cycling
                    const colorPhase = amplitude * settings.colorshift + this.time * 0.15 + wallIndex * 0.05;
                    const hue = (colorPhase + analysis.peak * 0.3) % 1;
                    wall.material.color.setHSL(hue, 0.9, 0.4 + amplitude * 0.6);
                    
                    // Scale variation for breathing effect
                    const scale = 1 + amplitude * settings.intensity * 0.4;
                    wall.scale.set(scale, scale, 1);
                });

                // Update tunnel rings with seamless cycling
                this.tunnelRings.forEach((ring, ringIndex) => {
                    ring.position.z = ring.userData.baseZ + this.tunnelPosition;
                    
                    const segmentCount = this.performance === 'high' ? 60 : this.performance === 'medium' ? 45 : 30;
                    const totalTunnelLength = segmentCount * 1.5;
                    
                    if (ring.position.z > 15) {
                        ring.position.z -= totalTunnelLength;
                        ring.userData.baseZ -= totalTunnelLength;
                    }
                    
                    const freqIndex = Math.floor((ringIndex / this.tunnelRings.length) * audioData.length);
                    const amplitude = audioData[freqIndex] / 255;
                    
                    // Ring rotation and scaling
                    ring.rotation.z += (0.01 + amplitude * 0.05) * settings.rotation;
                    const scale = (1 + amplitude * settings.intensity * 0.3) * settings.zoom;
                    ring.scale.setScalar(scale);
                    
                    // Ring color and opacity
                    const hue = (amplitude * settings.colorshift + this.time * 0.1 + ringIndex * 0.1) % 1;
                    ring.material.color.setHSL(hue, 0.8, 0.6);
                    ring.material.opacity = (0.3 + amplitude * 0.5) * settings.contrast;
                });

                // Update flowing particles with seamless cycling
                this.particles.forEach((particle, particleIndex) => {
                    const freqIndex = Math.floor((particleIndex / this.particles.length) * audioData.length);
                    const amplitude = audioData[particleIndex % audioData.length] / 255;
                    
                    // Continuous particle movement
                    particle.position.z += (particle.userData.speed + analysis.bass * 2) * settings.speed * 0.5;
                    
                    const segmentCount = this.performance === 'high' ? 60 : this.performance === 'medium' ? 45 : 30;
                    const totalTunnelLength = segmentCount * 1.5;
                    
                    if (particle.position.z > 10) {
                        particle.position.z -= totalTunnelLength;
                    }
                    
                    // Orbital motion
                    const time = this.time * 0.5 + particleIndex * 0.1;
                    const angle = particle.userData.angle + time * settings.rotation;
                    const radius = particle.userData.radius + amplitude * settings.orbsize;
                    
                    particle.position.x = Math.cos(angle) * radius + settings.center * 2;
                    particle.position.y = Math.sin(angle) * radius;
                    
                    // Particle effects
                    const scale = (1 + amplitude * settings.intensity * 2) * settings.zoom;
                    particle.scale.setScalar(scale);
                    
                    const hue = (amplitude * settings.colorshift + this.time * 0.2 + particleIndex * 0.05) % 1;
                    particle.material.color.setHSL(hue, 0.9, 0.7);
                    particle.material.opacity = (0.6 + amplitude * 0.4) * settings.contrast;
                });

                // Update multiple point lights
                const lights = [this.pointLight, this.pointLight2, this.pointLight3];
                lights.forEach((light, lightIndex) => {
                    if (light) {
                        const phase = this.time * (0.8 + lightIndex * 0.3);
                        const audioInfluence = [analysis.bass, analysis.mid, analysis.treble][lightIndex] || 0;
                        
                        light.position.z = 5 + Math.sin(phase) * 6 + audioInfluence * 3 * settings.orbsize;
                        light.position.x = Math.cos(phase * 0.7) * 3 + settings.center * 3;
                        light.position.y = Math.sin(phase * 0.5) * 2;
                        
                        light.intensity = (light.userData.baseIntensity + audioInfluence * 3) * settings.contrast;
                        
                        const hue = (audioInfluence * settings.colorshift + this.time * 0.1 + lightIndex * 0.3) % 1;
                        light.color.setHSL(hue, 0.9, 0.7);
                        light.distance = 15 + audioInfluence * 10;
                    }
                });
            }

            updateColors(colors) {
                this.colors = colors;
                
                // Update tunnel walls
                this.tunnelWalls.forEach(wall => {
                    wall.material.color.setHex(colors.primary);
                });
                
                // Update tunnel rings
                this.tunnelRings.forEach(ring => {
                    ring.material.color.setHex(colors.accent);
                });
                
                // Update particles
                this.particles.forEach(particle => {
                    particle.material.color.setHex(colors.accent);
                });
                
                // Update lights
                const lights = [this.pointLight, this.pointLight2, this.pointLight3];
                lights.forEach(light => {
                    if (light) {
                        light.color.setHex(colors.primary);
                    }
                });
            }

            dispose() {
                // Dispose tunnel walls
                this.tunnelWalls.forEach(wall => {
                    this.scene.remove(wall);
                    wall.geometry.dispose();
                    wall.material.dispose();
                });
                
                // Dispose tunnel rings
                this.tunnelRings.forEach(ring => {
                    this.scene.remove(ring);
                    ring.geometry.dispose();
                    ring.material.dispose();
                });
                
                // Dispose particles
                this.particles.forEach(particle => {
                    this.scene.remove(particle);
                    particle.geometry.dispose();
                    particle.material.dispose();
                });
                
                this.tunnelWalls = [];
                this.tunnelRings = [];
                this.particles = [];
                this.scene.fog = null;
            }
        }

        // Cosmic Spheres - Multi-sphere particle system
        class CosmicSpheresVisualizer {
            constructor(scene, colors, performance) {
                this.scene = scene;
                this.colors = colors;
                this.performance = performance;
                this.spheres = [];
                this.particleSystems = [];
                this.connections = [];
                this.shockwaves = [];
                this.time = 0;
                this.beatHistory = [];
                this.createCosmicSpheres();
            }

            createCosmicSpheres() {
                // Create 5 interconnected spheres, each responding to different frequency bands
                const sphereCount = 5;
                const particleCount = this.performance === 'high' ? 2000 : this.performance === 'medium' ? 1500 : 1000;
                const particlesPerSphere = Math.floor(particleCount / sphereCount);
                
                for (let s = 0; s < sphereCount; s++) {
                    const sphereData = {
                        particles: [],
                        center: new THREE.Vector3(),
                        radius: 2 + s * 0.5,
                        rotationSpeed: 0.01 + s * 0.005,
                        frequencyBand: s, // 0=bass, 1=low-mid, 2=mid, 3=high-mid, 4=treble
                        noiseScale: 1 + s * 0.3,
                        turbulence: 0,
                        dissolving: false,
                        reforming: false,
                        lifespan: 1.0
                    };
                    
                    // Position spheres in a pattern
                    const angle = (s / sphereCount) * Math.PI * 2;
                    sphereData.center.set(
                        Math.cos(angle) * 4,
                        Math.sin(angle) * 4,
                        Math.sin(angle * 2) * 2
                    );
                    
                    // Create particles for this sphere
                    for (let p = 0; p < particlesPerSphere; p++) {
                        const geometry = new THREE.SphereGeometry(0.02, 4, 4);
                        const material = new THREE.MeshBasicMaterial({
                            color: this.colors.primary,
                            transparent: true,
                            opacity: 0.8,
                            blending: THREE.AdditiveBlending
                        });
                        
                        const particle = new THREE.Mesh(geometry, material);
                        
                        // Random position within sphere
                        const phi = Math.random() * Math.PI * 2;
                        const theta = Math.random() * Math.PI;
                        const radius = Math.random() * sphereData.radius;
                        
                        particle.position.set(
                            sphereData.center.x + Math.sin(theta) * Math.cos(phi) * radius,
                            sphereData.center.y + Math.sin(theta) * Math.sin(phi) * radius,
                            sphereData.center.z + Math.cos(theta) * radius
                        );
                        
                        particle.userData = {
                            sphereIndex: s,
                            particleIndex: p,
                            basePosition: particle.position.clone(),
                            velocity: new THREE.Vector3(
                                (Math.random() - 0.5) * 0.02,
                                (Math.random() - 0.5) * 0.02,
                                (Math.random() - 0.5) * 0.02
                            ),
                            life: Math.random(),
                            maxLife: 1 + Math.random() * 2,
                            noiseOffset: new THREE.Vector3(
                                Math.random() * 100,
                                Math.random() * 100,
                                Math.random() * 100
                            )
                        };
                        
                        sphereData.particles.push(particle);
                        this.scene.add(particle);
                    }
                    
                    this.spheres.push(sphereData);
                }

                // Create connections between spheres
                for (let i = 0; i < sphereCount; i++) {
                    for (let j = i + 1; j < sphereCount; j++) {
                        const geometry = new THREE.BufferGeometry();
                        const positions = new Float32Array([
                            this.spheres[i].center.x, this.spheres[i].center.y, this.spheres[i].center.z,
                            this.spheres[j].center.x, this.spheres[j].center.y, this.spheres[j].center.z
                        ]);
                        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        
                        const material = new THREE.LineBasicMaterial({
                            color: this.colors.accent,
                            transparent: true,
                            opacity: 0.3,
                            blending: THREE.AdditiveBlending
                        });
                        
                        const connection = new THREE.Line(geometry, material);
                        connection.userData = {
                            sphere1: i,
                            sphere2: j,
                            positions: positions,
                            baseOpacity: 0.3
                        };
                        
                        this.connections.push(connection);
                        this.scene.add(connection);
                    }
                }

                // Create shockwave system for beat detection
                for (let i = 0; i < 10; i++) {
                    const geometry = new THREE.RingGeometry(0.1, 0.2, 16);
                    const material = new THREE.MeshBasicMaterial({
                        color: this.colors.secondary,
                        transparent: true,
                        opacity: 0,
                        side: THREE.DoubleSide,
                        blending: THREE.AdditiveBlending
                    });
                    
                    const shockwave = new THREE.Mesh(geometry, material);
                    shockwave.userData = {
                        active: false,
                        startTime: 0,
                        duration: 2000, // ms
                        maxRadius: 15,
                        origin: new THREE.Vector3()
                    };
                    
                    this.shockwaves.push(shockwave);
                    this.scene.add(shockwave);
                }

                // Cosmic background
                this.scene.fog = new THREE.Fog(0x000011, 10, 100);
                
                // Ambient cosmic lighting
                const ambientLight = new THREE.AmbientLight(0x221144, 0.3);
                this.scene.add(ambientLight);
                
                // Dynamic point lights for each sphere
                this.spheres.forEach((sphere, index) => {
                    const pointLight = new THREE.PointLight(this.colors.primary, 1.0, 20);
                    pointLight.position.copy(sphere.center);
                    pointLight.userData = { sphereIndex: index };
                    this.scene.add(pointLight);
                    sphere.light = pointLight;
                });
            }

            update(audioData, settings, analysis) {
                if (!audioData) {
                    const time = Date.now() * 0.001;
                    audioData = new Uint8Array(1024);
                    for (let i = 0; i < audioData.length; i++) {
                        audioData[i] = Math.sin(time + i * 0.02) * 60 + 120;
                    }
                }

                this.time += 0.016 * settings.speed;

                // Beat detection for shockwaves
                const isBeat = analysis.peak > 0.7 && (this.beatHistory.length === 0 ||
                    this.time - this.beatHistory[this.beatHistory.length - 1] > 0.3);
                
                if (isBeat) {
                    this.beatHistory.push(this.time);
                    this.triggerShockwave();
                }

                // Update each cosmic sphere
                this.spheres.forEach((sphere, sphereIndex) => {
                    // Map sphere to frequency band
                    const frequencyBands = [analysis.bass, analysis.bass * 0.7 + analysis.mid * 0.3,
                                          analysis.mid, analysis.mid * 0.3 + analysis.treble * 0.7, analysis.treble];
                    const bandIntensity = frequencyBands[sphereIndex] || 0;
                    
                    // Update sphere center position with orbital motion
                    const angle = (sphereIndex / 5) * Math.PI * 2 + this.time * settings.rotation * 0.1;
                    const orbitalRadius = 4 + bandIntensity * settings.orbsize * 3;
                    sphere.center.set(
                        Math.cos(angle) * orbitalRadius + settings.center * 6,
                        Math.sin(angle) * orbitalRadius,
                        Math.sin(angle * 2 + this.time * 0.3) * 2 + sphereIndex * 0.5
                    );
                    
                    // Update sphere properties
                    sphere.rotationSpeed = (0.01 + sphereIndex * 0.005) * (1 + bandIntensity * 2) * settings.speed;
                    sphere.turbulence = bandIntensity * settings.warp * 2;
                    sphere.radius = (2 + sphereIndex * 0.5) * (1 + bandIntensity * 0.5) * settings.zoom;
                    
                    // Dissolving/reforming based on audio intensity
                    if (bandIntensity > 0.8 && !sphere.dissolving) {
                        sphere.dissolving = true;
                        sphere.reforming = false;
                    } else if (bandIntensity < 0.3 && sphere.dissolving) {
                        sphere.dissolving = false;
                        sphere.reforming = true;
                    }
                    
                    // Update particles in this sphere
                    sphere.particles.forEach((particle, particleIndex) => {
                        const userData = particle.userData;
                        
                        // Noise-based movement like liquid stardust
                        const noiseTime = this.time * settings.flow * 0.5;
                        const noiseX = Math.sin(noiseTime + userData.noiseOffset.x) * sphere.noiseScale;
                        const noiseY = Math.cos(noiseTime + userData.noiseOffset.y) * sphere.noiseScale;
                        const noiseZ = Math.sin(noiseTime * 0.7 + userData.noiseOffset.z) * sphere.noiseScale;
                        
                        // Orbital motion around sphere center
                        const orbitalTime = this.time * sphere.rotationSpeed;
                        const phi = userData.particleIndex * 0.1 + orbitalTime;
                        const theta = userData.particleIndex * 0.05 + orbitalTime * 0.7;
                        
                        const baseRadius = sphere.radius * (0.5 + Math.random() * 0.5);
                        const x = sphere.center.x + Math.sin(theta) * Math.cos(phi) * baseRadius + noiseX * settings.complexity;
                        const y = sphere.center.y + Math.sin(theta) * Math.sin(phi) * baseRadius + noiseY * settings.complexity;
                        const z = sphere.center.z + Math.cos(theta) * baseRadius + noiseZ * settings.complexity;
                        
                        // Add turbulence on frequency peaks
                        if (sphere.turbulence > 0.5) {
                            const turbulenceForce = sphere.turbulence * settings.intensity;
                            particle.position.x = x + (Math.random() - 0.5) * turbulenceForce;
                            particle.position.y = y + (Math.random() - 0.5) * turbulenceForce;
                            particle.position.z = z + (Math.random() - 0.5) * turbulenceForce;
                        } else {
                            particle.position.set(x, y, z);
                        }
                        
                        // Particle lifecycle
                        userData.life += 0.016 * settings.speed;
                        if (userData.life > userData.maxLife) {
                            userData.life = 0;
                            userData.maxLife = 1 + Math.random() * 2;
                        }
                        
                        // Dissolving/reforming effects
                        let opacity = 0.8;
                        if (sphere.dissolving) {
                            opacity *= Math.max(0, 1 - userData.life / userData.maxLife);
                        } else if (sphere.reforming) {
                            opacity *= Math.min(1, userData.life / userData.maxLife);
                        }
                        
                        // Scale based on audio and lifecycle
                        const scale = (1 + bandIntensity * settings.intensity) * settings.radius *
                                     (0.5 + Math.sin(userData.life * Math.PI) * 0.5);
                        particle.scale.setScalar(scale);
                        
                        // Color based on frequency band and position
                        const hue = (sphereIndex * 0.2 + bandIntensity * settings.colorshift +
                                    userData.life * 0.1 + this.time * 0.05) % 1;
                        particle.material.color.setHSL(hue, 0.9, 0.7 + bandIntensity * 0.3);
                        particle.material.opacity = opacity * (0.6 + bandIntensity * 0.4) * settings.contrast;
                    });
                    
                    // Update sphere lighting
                    if (sphere.light) {
                        sphere.light.position.copy(sphere.center);
                        sphere.light.intensity = (1 + bandIntensity * 3) * settings.contrast;
                        const hue = (sphereIndex * 0.2 + bandIntensity * settings.colorshift + this.time * 0.1) % 1;
                        sphere.light.color.setHSL(hue, 0.8, 0.6);
                    }
                });

                // Update connections between spheres
                this.connections.forEach(connection => {
                    const sphere1 = this.spheres[connection.userData.sphere1];
                    const sphere2 = this.spheres[connection.userData.sphere2];
                    const positions = connection.userData.positions;
                    
                    // Update connection positions
                    positions[0] = sphere1.center.x;
                    positions[1] = sphere1.center.y;
                    positions[2] = sphere1.center.z;
                    positions[3] = sphere2.center.x;
                    positions[4] = sphere2.center.y;
                    positions[5] = sphere2.center.z;
                    
                    connection.geometry.attributes.position.needsUpdate = true;
                    
                    // Connection intensity based on both spheres
                    const band1 = [analysis.bass, analysis.bass * 0.7 + analysis.mid * 0.3,
                                  analysis.mid, analysis.mid * 0.3 + analysis.treble * 0.7, analysis.treble][connection.userData.sphere1];
                    const band2 = [analysis.bass, analysis.bass * 0.7 + analysis.mid * 0.3,
                                  analysis.mid, analysis.mid * 0.3 + analysis.treble * 0.7, analysis.treble][connection.userData.sphere2];
                    const avgIntensity = (band1 + band2) * 0.5;
                    
                    connection.material.opacity = (connection.userData.baseOpacity + avgIntensity * 0.7) * settings.contrast;
                    
                    const hue = (avgIntensity * settings.colorshift + this.time * 0.08) % 1;
                    connection.material.color.setHSL(hue, 0.8, 0.6);
                });

                // Update shockwaves
                this.shockwaves.forEach(shockwave => {
                    if (shockwave.userData.active) {
                        const elapsed = this.time * 1000 - shockwave.userData.startTime;
                        const progress = elapsed / shockwave.userData.duration;
                        
                        if (progress >= 1) {
                            shockwave.userData.active = false;
                            shockwave.material.opacity = 0;
                        } else {
                            // Expand shockwave
                            const radius = progress * shockwave.userData.maxRadius;
                            shockwave.scale.setScalar(radius);
                            
                            // Fade out over time
                            const opacity = (1 - progress) * 0.8 * settings.contrast;
                            shockwave.material.opacity = opacity;
                            
                            // Color shift
                            const hue = (progress * 0.5 + this.time * 0.1) % 1;
                            shockwave.material.color.setHSL(hue, 0.9, 0.7);
                        }
                    }
                });
            }

            triggerShockwave() {
                // Find inactive shockwave
                const inactiveShockwave = this.shockwaves.find(sw => !sw.userData.active);
                if (inactiveShockwave) {
                    inactiveShockwave.userData.active = true;
                    inactiveShockwave.userData.startTime = this.time * 1000;
                    
                    // Position at random sphere center
                    const randomSphere = this.spheres[Math.floor(Math.random() * this.spheres.length)];
                    inactiveShockwave.position.copy(randomSphere.center);
                    inactiveShockwave.scale.setScalar(0.1);
                }
            }

            updateColors(colors) {
                this.colors = colors;
                
                // Update sphere particles
                this.spheres.forEach(sphere => {
                    sphere.particles.forEach(particle => {
                        particle.material.color.setHex(colors.primary);
                    });
                    
                    if (sphere.light) {
                        sphere.light.color.setHex(colors.primary);
                    }
                });
                
                // Update connections
                this.connections.forEach(connection => {
                    connection.material.color.setHex(colors.accent);
                });
                
                // Update shockwaves
                this.shockwaves.forEach(shockwave => {
                    shockwave.material.color.setHex(colors.secondary);
                });
            }

            dispose() {
                // Dispose sphere particles
                this.spheres.forEach(sphere => {
                    sphere.particles.forEach(particle => {
                        this.scene.remove(particle);
                        particle.geometry.dispose();
                        particle.material.dispose();
                    });
                    
                    if (sphere.light) {
                        this.scene.remove(sphere.light);
                    }
                });
                
                // Dispose connections
                this.connections.forEach(connection => {
                    this.scene.remove(connection);
                    connection.geometry.dispose();
                    connection.material.dispose();
                });
                
                // Dispose shockwaves
                this.shockwaves.forEach(shockwave => {
                    this.scene.remove(shockwave);
                    shockwave.geometry.dispose();
                    shockwave.material.dispose();
                });
                
                this.spheres = [];
                this.connections = [];
                this.shockwaves = [];
                this.scene.fog = null;
            }
        }

        // Fullscreen Psychedelic Fractal Visualizer
        class FullscreenPsychedelicVisualizer {
            constructor(scene, colors, performance) {
                this.scene = scene;
                this.colors = colors;
                this.performance = performance;
                this.time = 0;
                this.plane = null;
                this.createPsychedelicShader();
            }

            createPsychedelicShader() {
                const geometry = new THREE.PlaneGeometry(2, 2);
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        u_res: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                        u_time: { value: 0 },
                        u_bass: { value: 0 },
                        u_mid: { value: 0 },
                        u_treble: { value: 0 },
                        u_center: { value: new THREE.Vector2(0.0, 0.0) },
                        u_scale: { value: 1.0 },
                        u_rot: { value: 0 },
                        u_symmetry: { value: 6.0 },
                        u_maxIter: { value: 50.0 },
                        u_warp: { value: 0.1 },
                        u_distortion: { value: 0.5 },
                        u_kaleidoscope: { value: 1.0 },
                        u_morphing: { value: 0.8 },
                        u_fractal: { value: 1.0 },
                        colorPrimary: { value: new THREE.Color(this.colors.primary) },
                        colorSecondary: { value: new THREE.Color(this.colors.secondary) },
                        colorAccent: { value: new THREE.Color(this.colors.accent) }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        precision mediump float;
                        
                        uniform vec2 u_res;
                        uniform float u_time;
                        uniform float u_bass;
                        uniform float u_mid;
                        uniform float u_treble;
                        uniform vec2 u_center;
                        uniform float u_scale;
                        uniform float u_rot;
                        uniform float u_symmetry;
                        uniform float u_maxIter;
                        uniform float u_warp;
                        uniform float u_distortion;
                        uniform float u_kaleidoscope;
                        uniform float u_morphing;
                        uniform float u_fractal;
                        uniform vec3 colorPrimary;
                        uniform vec3 colorSecondary;
                        uniform vec3 colorAccent;
                        
                        varying vec2 vUv;

                        mat2 rot(float a) { 
                            float s = sin(a), c = cos(a); 
                            return mat2(c, -s, s, c); 
                        }

                        vec2 distort(vec2 uv, float time, float intensity) {
                            uv += vec2(
                                sin(uv.y * 8.0 + time * 2.0) * intensity,
                                cos(uv.x * 6.0 - time * 1.5) * intensity
                            );
                            
                            float r = length(uv);
                            float angle = atan(uv.y, uv.x);
                            angle += sin(r * 5.0 + time) * intensity * 0.5;
                            r += sin(angle * 3.0 + time * 0.7) * intensity * 0.3;
                            
                            return vec2(cos(angle) * r, sin(angle) * r);
                        }

                        vec2 kaleidoscope(vec2 uv, float sides, float morphing) {
                            float angle = atan(uv.y, uv.x);
                            float radius = length(uv);
                            
                            float dynamicSides = sides + sin(u_time * 0.3) * morphing * 2.0;
                            float slice = 6.28318 / dynamicSides;
                            angle = mod(angle, slice);
                            if (angle > slice * 0.5) angle = slice - angle;
                            
                            angle += radius * morphing * 0.5 + u_time * 0.2;
                            
                            return vec2(cos(angle) * radius, sin(angle) * radius);
                        }

                        float fractalPattern(vec2 uv, float time, float depth) {
                            vec2 z = vec2(0.0);
                            vec2 c = uv;
                            float it = 0.0;
                            
                            for(int i = 0; i < 50; i++) {
                                if(it >= u_maxIter * depth) break;
                                if(dot(z, z) > 4.0) break;
                                
                                vec2 z2 = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;
                                z2 += vec2(sin(time + it * 0.1), cos(time * 0.7 + it * 0.1)) * u_morphing * 0.1;
                                z = z2;
                                
                                it += 1.0;
                            }
                            
                            return it / (u_maxIter * depth);
                        }

                        void main() {
                            vec2 uv = (vUv - 0.5) * 2.0;
                            
                            uv = distort(uv, u_time, u_distortion * (0.3 + u_bass * 0.7));
                            
                            float swirl = (0.15 + 0.35 * u_treble) * u_time + u_bass * 2.0;
                            uv *= rot(u_rot + swirl);
                            
                            uv = kaleidoscope(uv, u_symmetry, u_morphing);
                            
                            uv += vec2(
                                sin(uv.y * 12.0 + u_time * 1.8) * u_warp * (0.5 + u_mid * 0.5),
                                sin(uv.x * 10.0 - u_time * 2.1) * u_warp * (0.5 + u_treble * 0.5)
                            );
                            
                            vec2 c = u_center + uv * u_scale;
                            
                            float fractal1 = fractalPattern(c, u_time, 1.0);
                            float fractal2 = fractalPattern(c * 1.5 + vec2(0.1, 0.0), u_time * 0.7, u_fractal);
                            float fractal3 = fractalPattern(c * 0.7 + vec2(0.0, 0.1), u_time * 1.3, u_fractal * 0.5);
                            
                            float combined = (fractal1 + fractal2 * 0.7 + fractal3 * 0.5) / 2.2;
                            
                            float hue1 = fract(combined * 2.0 + u_time * 0.3 * (1.0 + u_bass * 2.0));
                            float hue2 = fract(combined * 1.5 + u_time * 0.5 * (1.0 + u_mid * 1.5));
                            float hue3 = fract(combined * 0.8 + u_time * 0.7 * (1.0 + u_treble * 1.0));
                            
                            vec3 color1 = mix(colorPrimary, colorSecondary, sin(hue1 * 6.28318) * 0.5 + 0.5);
                            vec3 color2 = mix(colorSecondary, colorAccent, cos(hue2 * 4.0) * 0.5 + 0.5);
                            vec3 color3 = mix(colorAccent, colorPrimary, sin(hue3 * 8.0) * 0.5 + 0.5);
                            
                            vec3 finalColor = mix(color1, color2, abs(sin(combined * 3.14159 + u_time)));
                            finalColor = mix(finalColor, color3, abs(cos(combined * 6.28318 + u_time * 0.5)));
                            
                            float brightness = 1.0 + sin(combined * 5.0 + u_time * 2.0) * 0.3;
                            brightness *= (1.0 + u_kaleidoscope * (u_bass * 0.8 + u_mid * 0.6 + u_treble * 0.4));
                            
                            finalColor *= brightness;
                            
                            float glow = smoothstep(0.0, 1.0, combined) * (0.3 + u_kaleidoscope * (u_treble * 0.7 + u_bass * 0.3));
                            finalColor += glow * mix(colorAccent, colorPrimary, sin(u_time * 3.0) * 0.5 + 0.5);
                            
                            vec3 gray = vec3(dot(finalColor, vec3(0.299, 0.587, 0.114)));
                            finalColor = mix(gray, finalColor, 1.5 + u_morphing * 0.5);
                            
                            finalColor = pow(finalColor, vec3(0.7));
                            
                            gl_FragColor = vec4(finalColor, 1.0);
                        }
                    `,
                    transparent: false
                });

                this.plane = new THREE.Mesh(geometry, material);
                this.scene.add(this.plane);
            }

            update(audioData, settings, analysis) {
                if (!this.plane) return;

                this.time += 0.016 * settings.speed;
                
                const uniforms = this.plane.material.uniforms;
                uniforms.u_time.value = this.time * 0.5;
                uniforms.u_bass.value = analysis.bass * settings.intensity;
                uniforms.u_mid.value = analysis.mid * settings.intensity;
                uniforms.u_treble.value = analysis.treble * settings.intensity;
                uniforms.u_center.value.set(settings.center * 0.5, 0.0);
                uniforms.u_scale.value = settings.zoom * 2.0;
                uniforms.u_rot.value = this.time * 0.1 * settings.rotation;
                uniforms.u_symmetry.value = settings.sides;
                uniforms.u_maxIter.value = Math.min(settings.maxiter, 80);
                uniforms.u_warp.value = settings.warp * (0.1 + analysis.bass * 0.3);
                uniforms.u_distortion.value = settings.distortion * (0.5 + analysis.peak * 0.5);
                uniforms.u_kaleidoscope.value = settings.kaleidoscope * (1.0 + analysis.treble * 0.5);
                uniforms.u_morphing.value = settings.morphing * (0.8 + analysis.mid * 0.4);
                uniforms.u_fractal.value = settings.fractal;
                
                uniforms.u_res.value.set(window.innerWidth, window.innerHeight);
            }

            updateColors(colors) {
                this.colors = colors;
                if (this.plane) {
                    const uniforms = this.plane.material.uniforms;
                    uniforms.colorPrimary.value.setHex(colors.primary);
                    uniforms.colorSecondary.value.setHex(colors.secondary);
                    uniforms.colorAccent.value.setHex(colors.accent);
                }
            }

            dispose() {
                if (this.plane) {
                    this.scene.remove(this.plane);
                    this.plane.geometry.dispose();
                    this.plane.material.dispose();
                    this.plane = null;
                }
            }
        }

        // Fullscreen DMT Tunnel Visualizer
        class FullscreenDMTVisualizer {
            constructor(scene, colors, performance) {
                this.scene = scene;
                this.colors = colors;
                this.performance = performance;
                this.time = 0;
                this.plane = null;
                this.createDMTShader();
            }

            createDMTShader() {
                const geometry = new THREE.PlaneGeometry(2, 2);
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        u_res: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                        u_time: { value: 0 },
                        u_bass: { value: 0 },
                        u_mid: { value: 0 },
                        u_treble: { value: 0 },
                        u_center: { value: new THREE.Vector2(0.0, 0.0) },
                        u_zoom: { value: 1.0 },
                        u_rotation: { value: 0.0 },
                        u_warp: { value: 1.0 },
                        u_flow: { value: 1.0 },
                        u_complexity: { value: 1.5 },
                        u_colorshift: { value: 2.0 },
                        u_contrast: { value: 1.5 },
                        colorPrimary: { value: new THREE.Color(this.colors.primary) },
                        colorSecondary: { value: new THREE.Color(this.colors.secondary) },
                        colorAccent: { value: new THREE.Color(this.colors.accent) }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        precision mediump float;
                        
                        uniform vec2 u_res;
                        uniform float u_time;
                        uniform float u_bass;
                        uniform float u_mid;
                        uniform float u_treble;
                        uniform vec2 u_center;
                        uniform float u_zoom;
                        uniform float u_rotation;
                        uniform float u_warp;
                        uniform float u_flow;
                        uniform float u_complexity;
                        uniform float u_colorshift;
                        uniform float u_contrast;
                        uniform vec3 colorPrimary;
                        uniform vec3 colorSecondary;
                        uniform vec3 colorAccent;
                        
                        varying vec2 vUv;

                        mat2 rot(float a) {
                            float c = cos(a), s = sin(a);
                            return mat2(c, -s, s, c);
                        }

                        float pattern(vec2 p, float time) {
                            float n = 0.0;
                            n += sin(p.x * 2.0 + time) * cos(p.y * 1.5 + time * 0.7);
                            n += sin(p.x * 3.0 + time * 1.3) * cos(p.y * 2.5 + time * 0.5);
                            n += sin(length(p) * 4.0 + time * 2.0) * 0.5;
                            return n * 0.33;
                        }

                        void main() {
                            vec2 uv = (vUv - 0.5) * 2.0;
                            
                            uv = (uv - u_center) / u_zoom;
                            
                            float totalRotation = u_rotation + u_time * 0.1 + u_bass * 0.5;
                            uv *= rot(totalRotation);
                            
                            float dist = length(uv);
                            float angle = atan(uv.y, uv.x);
                            
                            float z = 1.0 / (dist + 0.1) - u_time * u_flow;
                            
                            vec2 flowUV = uv + vec2(
                                sin(angle * 3.0 + u_time * 0.8) * u_warp * 0.3,
                                cos(angle * 5.0 - u_time * 1.2) * u_warp * 0.2
                            );
                            
                            float tunnel1 = sin(z * 20.0 + pattern(flowUV * 2.0, u_time) * u_complexity);
                            float tunnel2 = cos(z * 15.0 + angle * 8.0 + u_time * 2.0);
                            float tunnel3 = sin(dist * 40.0 - u_time * 3.0 + pattern(flowUV * u_complexity, u_time) * 5.0);
                            
                            float combined = (tunnel1 + tunnel2 * 0.7 + tunnel3 * 0.5) / 2.2;
                            
                            float lattice = sin(angle * 16.0 + u_time) * sin(z * 8.0 + u_time * 1.5);
                            combined += lattice * 0.3;
                            
                            float colorPhase = combined + z * 0.3 + u_time * u_colorshift;
                            
                            vec3 color1 = mix(colorPrimary, colorSecondary, 
                                sin(colorPhase + u_bass * 3.0) * 0.5 + 0.5);
                            vec3 color2 = mix(colorSecondary, colorAccent, 
                                cos(colorPhase * 1.5 + u_mid * 2.0) * 0.5 + 0.5);
                            vec3 color3 = mix(colorAccent, colorPrimary, 
                                sin(colorPhase * 0.7 + u_treble * 4.0) * 0.5 + 0.5);
                            
                            vec3 finalColor = mix(color1, color2, abs(combined));
                            finalColor = mix(finalColor, color3, smoothstep(0.0, 1.0, abs(combined)));
                            
                            finalColor *= (1.0 + sin(z * 5.0 + u_time) * 0.2);
                            
                            float audioBoost = (u_bass * 0.8 + u_mid * 0.6 + u_treble * 0.4) * 2.0;
                            finalColor *= (0.8 + audioBoost) * u_contrast;
                            
                            float energy = sin(z * 10.0 + u_time * 2.0 + combined * 5.0) * 0.3 + 0.7;
                            finalColor *= energy;
                            
                            float glow = 1.0 / (1.0 + dist * dist);
                            finalColor += glow * colorAccent * audioBoost * 0.3;
                            
                            finalColor = pow(finalColor, vec3(0.8));
                            
                            gl_FragColor = vec4(finalColor, 1.0);
                        }
                    `,
                    transparent: false
                });

                this.plane = new THREE.Mesh(geometry, material);
                this.scene.add(this.plane);
            }

            update(audioData, settings, analysis) {
                if (!this.plane) return;

                this.time += 0.016 * settings.speed;
                
                const uniforms = this.plane.material.uniforms;
                uniforms.u_time.value = this.time * 0.3;
                uniforms.u_bass.value = analysis.bass * settings.intensity;
                uniforms.u_mid.value = analysis.mid * settings.intensity;
                uniforms.u_treble.value = analysis.treble * settings.intensity;
                uniforms.u_center.value.set(settings.center * 0.3, 0.0);
                uniforms.u_zoom.value = settings.zoom * 0.8;
                uniforms.u_rotation.value = this.time * 0.05 * settings.rotation;
                uniforms.u_warp.value = settings.warp * (0.5 + analysis.bass * 0.8);
                uniforms.u_flow.value = settings.flow * (0.8 + analysis.mid * 0.7);
                uniforms.u_complexity.value = settings.complexity * (1.0 + analysis.treble * 0.5);
                uniforms.u_colorshift.value = settings.colorshift * 0.5;
                uniforms.u_contrast.value = settings.contrast;
                
                uniforms.u_res.value.set(window.innerWidth, window.innerHeight);
            }

            updateColors(colors) {
                this.colors = colors;
                if (this.plane) {
                    const uniforms = this.plane.material.uniforms;
                    uniforms.colorPrimary.value.setHex(colors.primary);
                    uniforms.colorSecondary.value.setHex(colors.secondary);
                    uniforms.colorAccent.value.setHex(colors.accent);
                }
            }

            dispose() {
                if (this.plane) {
                    this.scene.remove(this.plane);
                    this.plane.geometry.dispose();
                    this.plane.material.dispose();
                    this.plane = null;
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            try {
                new UltimateAudioVisualizer();
            } catch (error) {
                console.error('Failed to initialize visualizer:', error);
                document.getElementById('error-text').textContent = 'Failed to initialize: ' + error.message;
                document.getElementById('error-message').style.display = 'block';
            }
        });
    </script>
</body>
</html>
