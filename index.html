<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Audio Visualizer Pro</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(45deg, #0f0f23, #1a1a2e, #16213e);
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            height: 100vh;
            transition: background 0.5s ease;
        }

        body.dark {
            background: #000000;
        }

        body.stars {
        background: #000;
        background-image: 
            /* Bright stars */
            radial-gradient(2px 2px at 10% 20%, rgba(255,255,255,0.9), transparent),
            radial-gradient(3px 3px at 70% 30%, rgba(255,255,255,0.9), transparent),
            radial-gradient(2px 2px at 85% 60%, rgba(255,255,255,0.8), transparent),

            /* Medium stars */
            radial-gradient(2px 2px at 25% 40%, rgba(255,255,255,0.6), transparent),
            radial-gradient(3px 3px at 15% 85%, rgba(255,255,255,0.5), transparent),
            radial-gradient(2px 2px at 60% 75%, rgba(255,255,255,0.5), transparent),

            /* Dim stars */
            radial-gradient(2px 2px at 5% 95%, rgba(200,200,255,0.3), transparent),
            radial-gradient(2px 2px at 95% 15%, rgba(255,255,200,0.25), transparent),
            radial-gradient(2px 2px at 55% 45%, rgba(220,220,220,0.2), transparent);
        
        background-repeat: repeat;
        background-size: 300px 300px;

        /* Twinkling effect */
        animation: twinkle 1s infinite alternate ease-in-out;
        }

        @keyframes twinkle {
        0%   { opacity: 0.8; }
        50%  { opacity: 1; }
        100% { opacity: 0.6; }
        }

        body.matrix {
        background: 
            /* vertical streaks overlay */
            repeating-linear-gradient(
            180deg,rgba(0, 255, 0, 0.05) 0px, rgba(0, 255, 0, 0.05) 2px, transparent 2px, transparent 40px),
            /* animated glowing gradient */
            linear-gradient(135deg, #0f1419 0%, #0a0f0a 25%, #001100 50%, #002200 75%,#0d1f0d 100%);

        background-size: 100% 200%, 200% 200%;
        background-attachment: fixed;
        animation: matrixRain 20s linear infinite, matrixGlow 15s ease-in-out infinite alternate;
        }

        @keyframes matrixGlow {
        0%   { background-position: 0% 50%, 0% 50%; }
        50%  { background-position: 100% 50%, 100% 50%; }
        100% { background-position: 0% 50%, 0% 50%; }
        }

        @keyframes matrixRain {
        0%   { background-position: 0 0, 0 50%; }
        100% { background-position: 0 1000px, 0 50%; }
        }

        body.cosmic {
        background: #000; /* space black */

        /* stars */
        background-image: 
            radial-gradient(1px 1px at 10px 20px, #fff, transparent),
            radial-gradient(2px 2px at 40px 70px, rgba(255,255,255,0.8), transparent),
            radial-gradient(1px 1px at 90px 40px, rgba(255,255,255,0.6), transparent),
            radial-gradient(1px 2px at 130px 80px, rgba(255,255,255,0.5), transparent),
            radial-gradient(2px 1px at 160px 30px, rgba(255,255,255,0.7), transparent),

            /* colorful nebula blobs */
            radial-gradient(circle at 60px 200px, rgba(18, 4, 88, 0.6), transparent 60%),
            radial-gradient(circle at 250px 50px, rgba(255, 107, 160, 0.5), transparent 60%),
            radial-gradient(circle at 180px 150px, rgba(78, 205, 196, 0.4), transparent 70%),
            radial-gradient(circle at 300px 250px, rgba(180, 50, 255, 0.3), transparent 70%);

        background-repeat: repeat;
        background-size: 400px 400px;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #webgl-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(10, 10, 30, 0.95);
            backdrop-filter: blur(15px);
            border-radius: 15px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 255, 255, 0.2);
            transition: all 0.3s ease;
            min-width: 320px;
            max-height: 80vh;
            overflow-y: auto;
        }

        #controls:hover {
            border-color: rgba(0, 255, 255, 0.6);
            box-shadow: 0 12px 48px rgba(0, 255, 255, 0.3);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group.hidden {
            display: none;
        }

        label {
            display: block;
            color: #00ffff;
            font-size: 11px;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
            cursor: help;
        }

        select, input, button {
            background: rgba(15, 15, 35, 0.9);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 6px;
            color: #00ffff;
            padding: 8px 12px;
            font-size: 11px;
            width: 100%;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        select {
            background-color: rgba(15, 15, 35, 0.95);
        }

        select option {
            background-color: #0f0f23;
            color: #00ffff;
            padding: 5px;
        }

        select:hover, input:hover, button:hover {
            border-color: rgba(0, 255, 255, 0.6);
            background: rgba(20, 20, 40, 0.9);
            transform: translateY(-1px);
        }

        button {
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
            text-align: center;
        }

        button:active {
            transform: scale(0.95);
        }

        button.active {
            background: rgba(0, 255, 255, 0.3);
            border-color: rgba(0, 255, 255, 0.8);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
        }

        #fullscreen-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 200;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 1px solid rgba(0, 255, 255, 0.3);
            background: rgba(10, 10, 30, 0.9);
            backdrop-filter: blur(10px);
            color: #00ffff;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        #fullscreen-btn:hover {
            border-color: rgba(0, 255, 255, 0.8);
            background: rgba(0, 255, 255, 0.2);
            transform: scale(1.1);
        }

        #status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            color: rgba(0, 255, 255, 0.8);
            font-size: 11px;
            background: rgba(10, 10, 30, 0.8);
            padding: 12px 18px;
            border-radius: 25px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(10px);
        }

        .glow {
            filter: drop-shadow(0 0 15px rgba(0, 255, 255, 0.5));
        }

        input[type="range"] {
            -webkit-appearance: none;
            height: 4px;
            background: rgba(0, 255, 255, 0.2);
            border-radius: 2px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: linear-gradient(45deg, #00ffff, #0080ff);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.6);
            border: 1px solid rgba(0, 255, 255, 0.8);
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: linear-gradient(45deg, #00ffff, #0080ff);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.6);
            border: 1px solid rgba(0, 255, 255, 0.8);
        }

        .info {
            position: absolute;
            top: 20px;
            right: 90px;
            z-index: 100;
            color: rgba(0, 255, 255, 0.6);
            font-size: 10px;
            text-align: right;
            line-height: 1.4;
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }

        .advanced-controls {
            background: rgba(5, 5, 15, 0.8);
            border-radius: 8px;
            padding: 12px;
            margin-top: 10px;
            border: 1px solid rgba(0, 255, 255, 0.2);
        }

        .control-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 8px;
        }

        .control-row .control-group {
            margin-bottom: 5px;
        }

        .control-row label {
            font-size: 9px;
            margin-bottom: 3px;
        }

        .control-row input {
            padding: 4px 8px;
            font-size: 10px;
        }

        .error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 1000;
            display: none;
        }

        .performance-indicator {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(10, 10, 30, 0.8);
            padding: 8px 12px;
            border-radius: 15px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            font-size: 10px;
            color: #00ffff;
        }

        /* Auto-hide controls in fullscreen */
        body:-webkit-full-screen #controls,
        body:-moz-full-screen #controls,
        body:fullscreen #controls {
            opacity: 0.3;
            transition: opacity 0.3s ease;
        }

        body:-webkit-full-screen #controls:hover,
        body:-moz-full-screen #controls:hover,
        body:fullscreen #controls:hover {
            opacity: 1;
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            #controls {
                top: 10px;
                left: 10px;
                right: 10px;
                width: auto;
                padding: 15px;
                max-height: 70vh;
            }
            
            #fullscreen-btn {
                top: 10px;
                right: 10px;
            }
            
            #status {
                bottom: 10px;
                left: 10px;
                right: 10px;
                text-align: center;
            }

            .control-row {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="webgl-canvas"></canvas>
    </div>
    
    <div class="error-message" id="error-message">
        <h3>WebGL Error</h3>
        <p id="error-text">An error occurred while initializing the visualizer.</p>
        <button onclick="document.getElementById('error-message').style.display='none'">Close</button>
    </div>
    
    <div class="info">
        <div>Press F11 for fullscreen</div>
        <div>Use 1-4 keys to switch modes</div>
        <div>Space to start/stop audio</div>
        <div>H to hide/show controls</div>
    </div>

    <div id="fullscreen-btn" title="Toggle Fullscreen">⛶</div>

    <div class="performance-indicator">
        <div>GPU: <span id="gpu-info">Detecting...</span></div>
        <div>Quality: <span id="quality-level">High</span></div>
    </div>

    <div id="controls" class="glow">
        <div class="control-group">
            <label>🎵 Audio Source</label>
            <button id="start-capture" class="pulse">🎤 Start Microphone</button>
        </div>
        
        <div class="control-group">
            <label>🎨 Visualizer Mode</label>
            <select id="visualizer-mode">
                <option value="fractal">🌀 Fractal Reactor</option>
                <option value="tunnel">🕳️ 3D Tunnel</option>
                <option value="psychedelic">🌈 Psychedelic Fractal</option>
                <option value="dmt">🔮 DMT Tunnel</option>
            </select>
        </div>

        <div class="control-group">
            <label>🌈 Color Theme</label>
            <select id="color-theme">
                <option value="cyan">💎 Cyan Glow</option>
                <option value="rainbow">🌈 Rainbow</option>
                <option value="fire">🔥 Fire</option>
                <option value="electric">⚡ Electric Blue</option>
                <option value="neon">💖 Neon Pink</option>
                <option value="matrix">💚 Matrix Green</option>
                <option value="sunset">🌅 Sunset</option>
                <option value="cosmic">🌌 Cosmic Purple</option>
            </select>
        </div>

        <div class="control-group" id="sensitivity-group">
            <label title="Controls how much the visualizer responds to audio input">🎛️ Sensitivity: <span id="sensitivity-value">2.0</span></label>
            <input type="range" id="sensitivity" min="0.1" max="5" step="0.1" value="2">
        </div>

        <div class="control-group" id="speed-group">
            <label title="Controls animation speed and movement rate">⚡ Speed: <span id="speed-value">1.5</span></label>
            <input type="range" id="speed" min="0.1" max="4" step="0.1" value="1.5">
        </div>

        <div class="control-group" id="intensity-group">
            <label title="Controls brightness and overall energy of the effects">🔥 Intensity: <span id="intensity-value">2.0</span></label>
            <input type="range" id="intensity" min="0.1" max="5" step="0.1" value="2">
        </div>

        <div class="advanced-controls">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                <label>⚙️ Advanced Controls</label>
                <button id="reset-controls" style="width: auto; padding: 4px 12px; font-size: 10px;">🔄 Reset</button>
            </div>
            <div class="control-row">
                <div class="control-group" id="zoom-group">
                    <label title="Controls how zoomed in or out the visual effects appear">🔍 Zoom: <span id="zoom-value">1.0</span></label>
                    <input type="range" id="zoom" min="0.1" max="5" step="0.1" value="1">
                </div>
                <div class="control-group" id="contrast-group">
                    <label title="Controls the difference between light and dark areas">🌗 Contrast: <span id="contrast-value">1.2</span></label>
                    <input type="range" id="contrast" min="0.1" max="3" step="0.1" value="1.2">
                </div>
            </div>
            <div class="control-row">
                <div class="control-group" id="orbsize-group">
                    <label title="Controls the size of orbital movements and particle systems">⭕ Orbit Size: <span id="orbsize-value">1.0</span></label>
                    <input type="range" id="orbsize" min="0.1" max="3" step="0.1" value="1">
                </div>
                <div class="control-group" id="radius-group">
                    <label title="Controls the overall scale and spread of visual elements">📏 Scale: <span id="radius-value">1.0</span></label>
                    <input type="range" id="radius" min="0.1" max="3" step="0.1" value="1">
                </div>
            </div>
            <div class="control-row">
                <div class="control-group" id="colorshift-group">
                    <label title="Controls how fast colors cycle and change over time">🎨 Color Shift: <span id="colorshift-value">1.5</span></label>
                    <input type="range" id="colorshift" min="0.1" max="5" step="0.1" value="1.5">
                </div>
                <div class="control-group" id="center-group">
                    <label title="Shifts the center point of the visualization horizontally">🎯 Center X: <span id="center-value">0.0</span></label>
                    <input type="range" id="center" min="-2" max="2" step="0.1" value="0">
                </div>
            </div>
            <div class="control-row">
                <div class="control-group" id="sides-group">
                    <label title="Controls symmetry - number of repeated segments in kaleidoscope effects">🔢 Symmetry: <span id="sides-value">6</span></label>
                    <input type="range" id="sides" min="3" max="20" step="1" value="6">
                </div>
                <div class="control-group" id="rotation-group">
                    <label title="Controls rotation speed of spinning elements">🌀 Rotation: <span id="rotation-value">0.8</span></label>
                    <input type="range" id="rotation" min="0.1" max="5" step="0.1" value="0.8">
                </div>
            </div>
            <div class="control-row">
                <div class="control-group" id="warp-group">
                    <label title="Controls distortion and warping effects on the visuals">🌊 Warp: <span id="warp-value">0.3</span></label>
                    <input type="range" id="warp" min="0.0" max="2" step="0.1" value="0.3">
                </div>
                <div class="control-group" id="maxiter-group">
                    <label title="Controls detail level - higher values give more complex fractals">🎭 Iterations: <span id="maxiter-value">50</span></label>
                    <input type="range" id="maxiter" min="20" max="200" step="10" value="50">
                </div>
            </div>
            <div class="control-row">
                <div class="control-group" id="flow-group">
                    <label title="Controls how smoothly elements flow and transition">💫 Flow Speed: <span id="flow-value">1.0</span></label>
                    <input type="range" id="flow" min="0.1" max="3" step="0.1" value="1.0">
                </div>
                <div class="control-group" id="complexity-group">
                    <label title="Controls how intricate and detailed the patterns become">🔬 Complexity: <span id="complexity-value">1.2</span></label>
                    <input type="range" id="complexity" min="0.5" max="3" step="0.1" value="1.2">
                </div>
            </div>
            <div class="control-row">
                <div class="control-group" id="distortion-group">
                    <label title="Controls waviness and bending effects on the entire visual">🌀 Distortion: <span id="distortion-value">0.5</span></label>
                    <input type="range" id="distortion" min="0.0" max="2" step="0.1" value="0.5">
                </div>
                <div class="control-group" id="kaleidoscope-group">
                    <label title="Controls strength of mirror and kaleidoscope effects">💎 Kaleidoscope: <span id="kaleidoscope-value">1.0</span></label>
                    <input type="range" id="kaleidoscope" min="0.0" max="3" step="0.1" value="1.0">
                </div>
            </div>
            <div class="control-row">
                <div class="control-group" id="morphing-group">
                    <label title="Controls how shapes transform and change over time">🔄 Morphing: <span id="morphing-value">0.8</span></label>
                    <input type="range" id="morphing" min="0.0" max="2" step="0.1" value="0.8">
                </div>
                <div class="control-group" id="fractal-group">
                    <label title="Controls depth and recursiveness of fractal patterns">🌿 Fractal Depth: <span id="fractal-value">1.0</span></label>
                    <input type="range" id="fractal" min="0.5" max="3" step="0.1" value="1.0">
                </div>
            </div>
        </div>

        <div class="control-group">
            <label>🎭 Background</label>
            <select id="background-mode">
                <option value="gradient">🌌 Gradient</option>
                <option value="dark">🌑 Dark</option>
                <option value="stars">✨ Stars</option>
                <option value="matrix">💚 Matrix</option>
                <option value="cosmic">🪐 Cosmic</option>
            </select>
        </div>
    </div>

    <div id="status">
        <div>🎵 Status: <span id="audio-status">Click Start Microphone</span></div>
        <div>📊 FPS: <span id="fps-counter">0</span></div>
        <div>🎨 Mode: <span id="current-mode">Fractal Reactor</span></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        class UltimateAudioVisualizer {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.audioContext = null;
                this.analyser = null;
                this.dataArray = null;
                this.source = null;
                this.currentVisualizer = null;
                this.isCapturing = false;
                this.animationId = null;
                this.isWebGLSupported = true;
                this.performanceLevel = 'high';
                this.controlsVisible = true;
                
                this.settings = {
                    sensitivity: 2,
                    speed: 1.5,
                    intensity: 2,
                    colorTheme: 'cyan',
                    backgroundMode: 'gradient',
                    visualizerMode: 'fractal',
                    zoom: 1,
                    contrast: 1.2,
                    orbsize: 1,
                    radius: 1,
                    colorshift: 1.5,
                    center: 0,
                    sides: 6,
                    rotation: 0.8,
                    warp: 0.3,
                    maxiter: 50,
                    flow: 1.0,
                    complexity: 1.2,
                    distortion: 0.5,
                    kaleidoscope: 1.0,
                    morphing: 0.8,
                    fractal: 1.0
                };

                this.audioAnalysis = {
                    bass: 0, mid: 0, treble: 0, peak: 0, average: 0, history: [], 
                    rms: 0, beat: false, energyTrend: 0
                };

                this.modeControls = {
                    fractal: ['sensitivity', 'speed', 'intensity', 'zoom', 'contrast', 'orbsize', 'colorshift', 'center', 'rotation'],
                    tunnel: ['sensitivity', 'speed', 'intensity', 'zoom', 'contrast', 'colorshift', 'center', 'rotation', 'orbsize', 'warp'],
                    psychedelic: ['sensitivity', 'speed', 'intensity', 'zoom', 'contrast', 'colorshift', 'center', 'sides', 'rotation', 'warp', 'maxiter', 'distortion', 'kaleidoscope', 'morphing', 'fractal'],
                    dmt: ['sensitivity', 'speed', 'intensity', 'zoom', 'contrast', 'colorshift', 'center', 'rotation', 'warp', 'flow', 'complexity']
                };

                this.modeDefaults = {
                    fractal: {
                        sensitivity: 2.2, speed: 1.0, intensity: 2.2, zoom: 0.4, contrast: 1.4,
                        orbsize: 2.0, radius: 1.0, colorshift: 0.9, center: 0.0, sides: 16,
                        rotation: 0.9, warp: 0.2, maxiter: 40, flow: 1.0, complexity: 2.0,
                        distortion: 0.3, kaleidoscope: 0.8, morphing: 0.5, fractal: 0.8
                    },
                    tunnel: {
                        sensitivity: 0.6, speed: 0.3, intensity: 0.6, zoom: 1.1, contrast: 0.9,
                        orbsize: 1.7, radius: 1.0, colorshift: 3.1, center: 0.0, sides: 10,
                        rotation: 3.9, warp: 1.6, maxiter: 25, flow: 1.0, complexity: 0.8,
                        distortion: 0.2, kaleidoscope: 0.6, morphing: 0.4, fractal: 0.7
                    },
                    psychedelic: {
                        sensitivity: 3.0, speed: 1.2, intensity: 0.8, zoom: 1.2, contrast: 0.5,
                        orbsize: 1.4, radius: 1.4, colorshift: 1.4, center: 0.0, sides: 9,
                        rotation: 0.5, warp: 0.6, maxiter: 80, flow: 1.0, complexity: 1.2,
                        distortion: 0.3, kaleidoscope: 2.3, morphing: 0.4, fractal: 2.8
                    },
                    dmt: {
                        sensitivity: 3.2, speed: 1.0, intensity: 3.0, zoom: 1.3, contrast: 0.4,
                        orbsize: 1.5, radius: 1.6, colorshift: 2.8, center: 0.0, sides: 8,
                        rotation: 0.6, warp: 0.8, maxiter: 100, flow: 1.6, complexity: 1.8,
                        distortion: 1.0, kaleidoscope: 1.8, morphing: 1.5, fractal: 2.0
                    }
                };

                this.colorThemes = {
                    cyan: { primary: 0x00ffff, secondary: 0x0080ff, accent: 0x00ff80 },
                    rainbow: { primary: 0xff0080, secondary: 0x8000ff, accent: 0x00ff80 },
                    fire: { primary: 0xff4000, secondary: 0xff8000, accent: 0xffff00 },
                    electric: { primary: 0x0040ff, secondary: 0x4080ff, accent: 0x80c0ff },
                    neon: { primary: 0xff0080, secondary: 0xff4080, accent: 0xff80c0 },
                    matrix: { primary: 0x00ff41, secondary: 0x008f11, accent: 0x00ff88 },
                    sunset: { primary: 0xff6b35, secondary: 0xff8c42, accent: 0xffd23f },
                    cosmic: { primary: 0x9b59b6, secondary: 0x8e44ad, accent: 0x3498db }
                };

                this.fpsCounter = 0;
                this.lastFpsTime = performance.now();
                this.beatDetector = {
                    history: [],
                    threshold: 0.7,
                    lastBeat: 0,
                    energy: 0
                };
                this.spectrumAnalyzer = {
                    frequencyBands: 32,
                    smoothingFactor: 0.8,
                    bandData: new Array(32).fill(0)
                };

                this.init();
            }

            detectBeats(audioData, analysis) {
                if (!audioData) return false;
                
                // Calculate instantaneous energy
                let energy = 0;
                for (let i = 0; i < Math.min(audioData.length * 0.3, 256); i++) {
                    energy += audioData[i] * audioData[i];
                }
                energy /= Math.min(audioData.length * 0.3, 256);
                
                this.beatDetector.history.push(energy);
                if (this.beatDetector.history.length > 30) {
                    this.beatDetector.history.shift();
                }
                
                // Calculate average energy
                const avgEnergy = this.beatDetector.history.reduce((sum, e) => sum + e, 0) / this.beatDetector.history.length;
                
                // Beat detection
                const now = performance.now();
                const timeSinceLastBeat = now - this.beatDetector.lastBeat;
                const isBeat = energy > avgEnergy * 1.3 && timeSinceLastBeat > 300; // Min 300ms between beats
                
                if (isBeat) {
                    this.beatDetector.lastBeat = now;
                    return true;
                }
                return false;
            }

            analyzeSpectrum(audioData) {
                if (!audioData) return;
                
                const bandsPerGroup = Math.floor(audioData.length / this.spectrumAnalyzer.frequencyBands);
                
                for (let i = 0; i < this.spectrumAnalyzer.frequencyBands; i++) {
                    let bandSum = 0;
                    const startIdx = i * bandsPerGroup;
                    const endIdx = Math.min(startIdx + bandsPerGroup, audioData.length);
                    
                    for (let j = startIdx; j < endIdx; j++) {
                        bandSum += audioData[j];
                    }
                    
                    const bandAvg = bandSum / (endIdx - startIdx);
                    const smoothing = this.spectrumAnalyzer.smoothingFactor;
                    this.spectrumAnalyzer.bandData[i] = this.spectrumAnalyzer.bandData[i] * smoothing + bandAvg * (1 - smoothing);
                }
            }

            showError(message) {
                document.getElementById('error-text').textContent = message;
                document.getElementById('error-message').style.display = 'block';
                console.error('Visualizer Error:', message);
            }

            detectGPU() {
                try {
                    const canvas = document.createElement('canvas');
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    if (!gl) {
                        this.performanceLevel = 'low';
                        return 'WebGL Not Supported';
                    }
                    
                    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                    const renderer = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : 'Unknown GPU';
                    
                    if (renderer.includes('Intel') || renderer.includes('Software')) {
                        this.performanceLevel = 'medium';
                    } else if (renderer.includes('NVIDIA') || renderer.includes('AMD') || renderer.includes('Radeon')) {
                        this.performanceLevel = 'high';
                    }
                    
                    document.getElementById('gpu-info').textContent = renderer.substring(0, 20) + '...';
                    document.getElementById('quality-level').textContent = this.performanceLevel.charAt(0).toUpperCase() + this.performanceLevel.slice(1);
                    
                    return renderer;
                } catch (e) {
                    this.performanceLevel = 'low';
                    return 'Unknown';
                }
            }

            init() {
                try {
                    this.detectGPU();
                    this.setupThreeJS();
                    this.setupEventListeners();
                    this.updateBackground();
                    this.updateControlVisibility();
                    this.animate();
                    this.showWelcomeMessage();
                } catch (error) {
                    this.showError('Failed to initialize: ' + error.message);
                }
            }

            showWelcomeMessage() {
                setTimeout(() => {
                    document.getElementById('audio-status').innerHTML = 
                        '<span class="pulse">🎵 Ready! Click Start Microphone 🎤</span>';
                }, 1000);
            }

            setupThreeJS() {
                const canvas = document.getElementById('webgl-canvas');
                
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (!gl) {
                    this.showError('WebGL is not supported on this device. Please use a modern browser.');
                    this.isWebGLSupported = false;
                    return;
                }

                this.scene = new THREE.Scene();
                
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 0, 8);

                try {
                    this.renderer = new THREE.WebGLRenderer({ 
                        canvas: canvas,
                        antialias: this.performanceLevel === 'high', 
                        alpha: false,
                        powerPreference: "high-performance",
                        precision: "mediump"
                    });
                    
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    this.renderer.setClearColor(0x000000, 1);
                    
                    const pixelRatio = this.performanceLevel === 'high' ? 
                        Math.min(window.devicePixelRatio, 2) : 1;
                    this.renderer.setPixelRatio(pixelRatio);
                    
                } catch (error) {
                    this.showError('Failed to create WebGL renderer: ' + error.message);
                    return;
                }

                this.applyModeDefaults('fractal');
                this.switchVisualizer('fractal');

                window.addEventListener('resize', () => this.onWindowResize());
            }

            updateControlVisibility() {
                const currentMode = this.settings.visualizerMode;
                const relevantControls = this.modeControls[currentMode] || [];
                
                const allControls = ['zoom', 'contrast', 'orbsize', 'radius', 'colorshift', 'center', 'sides', 'rotation', 'warp', 'maxiter', 'flow', 'complexity', 'distortion', 'kaleidoscope', 'morphing', 'fractal'];
                allControls.forEach(control => {
                    const group = document.getElementById(`${control}-group`);
                    if (group) {
                        group.classList.add('hidden');
                    }
                });
                
                relevantControls.forEach(control => {
                    const group = document.getElementById(`${control}-group`);
                    if (group) {
                        group.classList.remove('hidden');
                    }
                });
            }

            applyModeDefaults(mode) {
                const defaults = this.modeDefaults[mode];
                if (!defaults) return;

                Object.keys(defaults).forEach(key => {
                    this.settings[key] = defaults[key];
                });

                Object.keys(defaults).forEach(key => {
                    const control = document.getElementById(key);
                    const valueSpan = document.getElementById(`${key}-value`);
                    
                    if (control && control.type === 'range') {
                        control.value = defaults[key];
                        if (valueSpan) {
                            valueSpan.textContent = defaults[key];
                        }
                    }
                });
            }

            setupEventListeners() {
                document.getElementById('start-capture').addEventListener('click', () => {
                    if (this.isCapturing) {
                        this.stopAudioCapture();
                    } else {
                        this.startAudioCapture();
                    }
                });

                document.getElementById('visualizer-mode').addEventListener('change', (e) => {
                    const newMode = e.target.value;
                    this.settings.visualizerMode = newMode;
                    
                    this.applyModeDefaults(newMode);
                    this.updateControlVisibility();
                    
                    this.switchVisualizer(newMode);
                    document.getElementById('current-mode').textContent = e.target.options[e.target.selectedIndex].text.split(' ').slice(1).join(' ');
                });

                document.getElementById('color-theme').addEventListener('change', (e) => {
                    this.settings.colorTheme = e.target.value;
                    if (this.currentVisualizer && this.currentVisualizer.updateColors) {
                        this.currentVisualizer.updateColors(this.colorThemes[e.target.value]);
                    }
                });

                const controls = ['sensitivity', 'speed', 'intensity', 'zoom', 'contrast', 'orbsize', 'radius', 'colorshift', 'center', 'sides', 'rotation', 'warp', 'maxiter', 'flow', 'complexity', 'distortion', 'kaleidoscope', 'morphing', 'fractal'];
                controls.forEach(control => {
                    const element = document.getElementById(control);
                    if (element) {
                        element.addEventListener('input', (e) => {
                            this.settings[control] = parseFloat(e.target.value);
                            const valueElement = document.getElementById(`${control}-value`);
                            if (valueElement) {
                                valueElement.textContent = e.target.value;
                            }
                        });
                    }
                });

                document.getElementById('reset-controls').addEventListener('click', () => {
                    this.applyModeDefaults(this.settings.visualizerMode);
                });

                document.getElementById('background-mode').addEventListener('change', (e) => {
                    this.settings.backgroundMode = e.target.value;
                    this.updateBackground();
                });

                document.getElementById('fullscreen-btn').addEventListener('click', () => {
                    this.toggleFullscreen();
                });

                document.addEventListener('keydown', (e) => {
                    switch(e.code) {
                        case 'Space':
                            e.preventDefault();
                            if (this.isCapturing) {
                                this.stopAudioCapture();
                            } else {
                                this.startAudioCapture();
                            }
                            break;
                        case 'F11':
                            e.preventDefault();
                            this.toggleFullscreen();
                            break;
                        case 'KeyH':
                            e.preventDefault();
                            this.toggleControls();
                            break;
                        case 'Digit1':
                        case 'Digit2':
                        case 'Digit3':
                        case 'Digit4':
                            e.preventDefault();
                            const modes = ['fractal', 'tunnel', 'psychedelic', 'dmt'];
                            const modeIndex = parseInt(e.code.slice(-1)) - 1;
                            if (modes[modeIndex]) {
                                const newMode = modes[modeIndex];
                                document.getElementById('visualizer-mode').value = newMode;
                                this.settings.visualizerMode = newMode;
                                this.applyModeDefaults(newMode);
                                this.updateControlVisibility();
                                this.switchVisualizer(newMode);
                                document.getElementById('current-mode').textContent = 
                                    document.getElementById('visualizer-mode').options[modeIndex].text.split(' ').slice(1).join(' ');
                            }
                            break;
                    }
                });
            }

            toggleControls() {
                const controls = document.getElementById('controls');
                this.controlsVisible = !this.controlsVisible;
                controls.style.display = this.controlsVisible ? 'block' : 'none';
            }

            async startAudioCapture() {
                try {
                    document.getElementById('audio-status').textContent = 'Requesting microphone access...';
                    
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: 44100
                        } 
                    });

                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = 4096;
                    this.analyser.smoothingTimeConstant = 0.8;

                    this.source = this.audioContext.createMediaStreamSource(stream);
                    this.source.connect(this.analyser);

                    this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                    
                    this.isCapturing = true;
                    document.getElementById('audio-status').innerHTML = '🎵 <span class="pulse">Live! Play some music!</span>';
                    document.getElementById('start-capture').textContent = '🛑 Stop Capture';
                    document.getElementById('start-capture').classList.add('active');

                } catch (error) {
                    console.error('Error accessing microphone:', error);
                    document.getElementById('audio-status').textContent = '⌐ Microphone access denied';
                }
            }

            stopAudioCapture() {
                if (this.source) this.source.disconnect();
                if (this.audioContext) this.audioContext.close();
                
                this.isCapturing = false;
                document.getElementById('audio-status').textContent = 'Click Start Microphone to begin';
                document.getElementById('start-capture').textContent = '🎤 Start Microphone';
                document.getElementById('start-capture').classList.remove('active');
            }

            toggleFullscreen() {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(err => {
                        console.log('Error attempting to enable fullscreen:', err);
                    });
                } else {
                    document.exitFullscreen();
                }
            }

            analyzeAudio(audioData) {
                if (!audioData) return this.audioAnalysis;
                
                // Enhanced spectrum analysis
                this.analyzeSpectrum(audioData);
                
                const bufferLength = audioData.length;
                const bassEnd = Math.floor(bufferLength * 0.12);
                const midEnd = Math.floor(bufferLength * 0.45);
                const trebleStart = Math.floor(bufferLength * 0.65);
                
                let bassSum = 0, midSum = 0, trebleSum = 0, peak = 0, average = 0;
                
                // Enhanced frequency analysis with better separation
                for (let i = 0; i < bufferLength; i++) {
                    const value = audioData[i];
                    average += value;
                    peak = Math.max(peak, value);
                    
                    if (i < bassEnd) {
                        // Weight bass frequencies more heavily
                        bassSum += value * (i < bassEnd * 0.5 ? 2.0 : 1.0);
                    } else if (i < midEnd) {
                        midSum += value;
                    } else if (i >= trebleStart) {
                        // Emphasize higher treble frequencies
                        trebleSum += value * (i > trebleStart + (bufferLength - trebleStart) * 0.5 ? 1.5 : 1.0);
                    }
                }
                
                this.audioAnalysis.bass = Math.min((bassSum / (bassEnd * 1.5)) / 255, 1.0);
                this.audioAnalysis.mid = Math.min((midSum / (midEnd - bassEnd)) / 255, 1.0);
                this.audioAnalysis.treble = Math.min((trebleSum / (bufferLength - trebleStart * 0.8)) / 255, 1.0);
                this.audioAnalysis.peak = peak / 255;
                this.audioAnalysis.average = (average / bufferLength) / 255;
                
                // Beat detection
                const isBeat = this.detectBeats(audioData, this.audioAnalysis);
                this.audioAnalysis.beat = isBeat;
                
                // Calculate RMS for better energy detection
                let rms = 0;
                for (let i = 0; i < bufferLength; i++) {
                    rms += audioData[i] * audioData[i];
                }
                this.audioAnalysis.rms = Math.sqrt(rms / bufferLength) / 255;
                
                // Store history for advanced analysis
                this.audioAnalysis.history.push({
                    bass: this.audioAnalysis.bass,
                    mid: this.audioAnalysis.mid,
                    treble: this.audioAnalysis.treble,
                    peak: this.audioAnalysis.peak,
                    rms: this.audioAnalysis.rms,
                    beat: isBeat,
                    time: performance.now()
                });
                
                // Keep only recent history
                if (this.audioAnalysis.history.length > 60) { // 1 second at 60fps
                    this.audioAnalysis.history.shift();
                }
                
                // Calculate energy trends
                if (this.audioAnalysis.history.length > 10) {
                    const recent = this.audioAnalysis.history.slice(-10);
                    const older = this.audioAnalysis.history.slice(-20, -10);
                    
                    const recentAvg = recent.reduce((sum, h) => sum + h.rms, 0) / recent.length;
                    const olderAvg = older.length > 0 ? older.reduce((sum, h) => sum + h.rms, 0) / older.length : recentAvg;
                    
                    this.audioAnalysis.energyTrend = recentAvg - olderAvg;
                }
                
                return this.audioAnalysis;
            }

            switchVisualizer(mode) {
                if (!this.isWebGLSupported) return;

                if (this.currentVisualizer && this.currentVisualizer.dispose) {
                    this.currentVisualizer.dispose();
                }

                // Clear scene more thoroughly
                while(this.scene.children.length > 0) {
                    const child = this.scene.children[0];
                    this.scene.remove(child);
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => mat.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                }
                
                // Clear fog
                this.scene.fog = null;

                const colors = this.colorThemes[this.settings.colorTheme];

                try {
                    switch(mode) {
                        case 'fractal':
                            this.currentVisualizer = new EnhancedFractalVisualizer(this.scene, colors, this.performanceLevel);
                            this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                            this.camera.position.set(0, 0, 8);
                            break;
                        case 'tunnel':
                            this.currentVisualizer = new EnhancedTunnelVisualizer(this.scene, colors, this.performanceLevel);
                            this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                            this.camera.position.set(0, 0, 8);
                            break;
                        case 'psychedelic':
                            this.currentVisualizer = new FullscreenPsychedelicVisualizer(this.scene, colors, this.performanceLevel);
                            this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
                            this.camera.position.z = 1;
                            break;
                        case 'dmt':
                            this.currentVisualizer = new FullscreenDMTVisualizer(this.scene, colors, this.performanceLevel);
                            this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
                            this.camera.position.z = 1;
                            break;
                    }
                } catch (error) {
                    this.showError('Failed to create visualizer: ' + error.message);
                    this.currentVisualizer = new EnhancedFractalVisualizer(this.scene, colors, 'low');
                }
            }

            updateBackground() {
                const body = document.body;
                body.className = this.settings.backgroundMode;
                
                // Also update the renderer clear color based on background
                if (this.renderer) {
                    switch(this.settings.backgroundMode) {
                        case 'dark':
                            this.renderer.setClearColor(0x000000, 1);
                            break;
                        case 'matrix':
                            this.renderer.setClearColor(0x001100, 1);
                            break;
                        case 'cosmic':
                            this.renderer.setClearColor(0x120458, 1);
                            break;
                        case 'stars':
                            this.renderer.setClearColor(0x000000, 1);
                            break;
                        default:
                            this.renderer.setClearColor(0x0f0f23, 1);
                            break;
                    }
                }
            }

            animate() {
                if (!this.isWebGLSupported) return;

                this.animationId = requestAnimationFrame(() => this.animate());

                const frameStart = performance.now();

                // Dynamic performance adjustment
                const targetFPS = 60;
                const currentFPS = 1000 / (frameStart - this.lastFpsTime);
                if (this.fpsCounter % 60 === 0) { // Adjust every 60 frames
                    if (currentFPS < 30 && this.performanceLevel === 'high') {
                        this.performanceLevel = 'medium';
                        console.log('Performance adjusted to medium');
                    } else if (currentFPS < 20 && this.performanceLevel === 'medium') {
                        this.performanceLevel = 'low';
                        console.log('Performance adjusted to low');
                    } else if (currentFPS > 50 && this.performanceLevel === 'low') {
                        this.performanceLevel = 'medium';
                        console.log('Performance adjusted to medium');
                    } else if (currentFPS > 55 && this.performanceLevel === 'medium') {
                        this.performanceLevel = 'high';
                        console.log('Performance adjusted to high');
                    }
                }

                // FPS tracking
                this.fpsCounter++;
                if (frameStart - this.lastFpsTime >= 1000) {
                    document.getElementById('fps-counter').textContent = Math.round(this.fpsCounter);
                    this.fpsCounter = 0;
                    this.lastFpsTime = frameStart;
                }

                // Enhanced audio analysis
                let audioData = null;
                if (this.isCapturing && this.analyser) {
                    this.analyser.getByteFrequencyData(this.dataArray);
                    audioData = this.dataArray;
                }

                const analysis = this.analyzeAudio(audioData);

                // Beat-reactive background flash
                if (analysis.beat && this.settings.backgroundMode !== 'dark') {
                    const flash = Math.min(analysis.rms * 0.5, 0.3);
                    document.body.style.filter = `brightness(${1 + flash})`;
                    setTimeout(() => {
                        document.body.style.filter = 'brightness(1)';
                    }, 100);
                }

                // Dynamic camera effects for certain modes
                if (this.camera && this.currentVisualizer) {
                    const visualizerMode = this.settings.visualizerMode;
                    
                    if (visualizerMode === 'tunnel') {
                        // Slight camera movement in tunnel
                        const sway = Math.sin(frameStart * 0.001) * analysis.average * 0.5;
                        this.camera.position.x = sway + this.settings.center * 2;
                        this.camera.position.y = Math.cos(frameStart * 0.0008) * analysis.mid * 0.3;
                    } else if (visualizerMode === 'dmt' || visualizerMode === 'psychedelic') {
                        // Subtle zoom pulsing for shader modes
                        if (this.camera instanceof THREE.OrthographicCamera) {
                            const zoomPulse = 1 + analysis.rms * 0.1;
                            this.camera.zoom = zoomPulse;
                            this.camera.updateProjectionMatrix();
                        }
                    }
                }

                // Update visualizer with enhanced analysis
                if (this.currentVisualizer && this.currentVisualizer.update) {
                    // Add spectrum data to analysis for advanced visualizers
                    analysis.spectrum = this.spectrumAnalyzer.bandData;
                    analysis.energyTrend = this.audioAnalysis.energyTrend || 0;
                    
                    this.currentVisualizer.update(audioData, this.settings, analysis);
                }

                // Adaptive rendering quality
                if (this.renderer) {
                    // Reduce pixel ratio if performance is poor
                    const targetPixelRatio = this.performanceLevel === 'high' ? 
                        Math.min(window.devicePixelRatio, 2) : 
                        this.performanceLevel === 'medium' ? 1.5 : 1;
                    
                    if (Math.abs(this.renderer.getPixelRatio() - targetPixelRatio) > 0.1) {
                        this.renderer.setPixelRatio(targetPixelRatio);
                    }
                    
                    this.renderer.render(this.scene, this.camera);
                }

                // Update performance indicator
                const frameEnd = performance.now();
                const frameTime = frameEnd - frameStart;
                if (frameTime > 20) { // Frame took longer than 50fps
                    document.getElementById('quality-level').style.color = '#ff6666';
                } else if (frameTime > 16.67) { // Frame took longer than 60fps
                    document.getElementById('quality-level').style.color = '#ffaa66';
                } else {
                    document.getElementById('quality-level').style.color = '#66ff66';
                }
            }

            onWindowResize() {
                if (!this.isWebGLSupported) return;

                if (this.camera instanceof THREE.PerspectiveCamera) {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                }
                
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                
                if (this.currentVisualizer && this.currentVisualizer.plane && this.currentVisualizer.plane.material.uniforms) {
                    const uniforms = this.currentVisualizer.plane.material.uniforms;
                    if (uniforms.u_res) {
                        uniforms.u_res.value.set(window.innerWidth, window.innerHeight);
                    }
                }
            }
        }

        // Enhanced Fractal Visualizer
        class EnhancedFractalVisualizer {
            constructor(scene, colors, performance) {
                this.scene = scene;
                this.colors = colors;
                this.performance = performance;
                this.fractals = [];
                this.time = 0;
                this.createFractals();
            }

            createFractals() {
                const count = this.performance === 'high' ? 8 : this.performance === 'medium' ? 6 : 4;
                
                for (let level = 0; level < count; level++) {
                    const size = 2.5 - level * 0.3;
                    const detail = this.performance === 'high' ? level + 1 : 1;
                    const geometry = new THREE.IcosahedronGeometry(size, detail);
                    
                    const material = new THREE.MeshPhongMaterial({
                        color: this.colors.primary,
                        emissive: this.colors.primary,
                        emissiveIntensity: 0.4,
                        transparent: true,
                        opacity: 0.8 - level * 0.1,
                        wireframe: level % 2 === 1
                    });

                    const fractal = new THREE.Mesh(geometry, material);
                    fractal.userData = { level: level, baseSize: size };
                    this.fractals.push(fractal);
                    this.scene.add(fractal);
                }

                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);

                const pointLight = new THREE.PointLight(this.colors.accent, 3, 50);
                pointLight.position.set(0, 0, 10);
                this.scene.add(pointLight);
                this.pointLight = pointLight;
            }

            update(audioData, settings, analysis) {
                if (!audioData) {
                    const time = Date.now() * 0.001;
                    audioData = new Uint8Array(2048);
                    for (let i = 0; i < audioData.length; i++) {
                        audioData[i] = Math.sin(time + i * 0.02) * 60 + 120;
                    }
                }

                this.time += 0.016 * settings.speed;

                this.fractals.forEach((fractal, index) => {
                    const level = fractal.userData.level;
                    
                    let amplitude;
                    if (level < 2) amplitude = analysis.bass;
                    else if (level < 4) amplitude = analysis.mid;
                    else amplitude = analysis.treble;

                    const scale = (1 + amplitude * (4 + level * 0.5) * settings.intensity) * settings.zoom;
                    fractal.scale.setScalar(scale);
                    
                    const rotSpeed = settings.rotation * settings.speed;
                    fractal.rotation.x += (0.02 + amplitude * 0.15) * rotSpeed;
                    fractal.rotation.y += (0.025 + amplitude * 0.12) * rotSpeed;
                    fractal.rotation.z += (0.015 + amplitude * 0.08) * rotSpeed;
                    
                    fractal.material.emissiveIntensity = (0.4 + amplitude * 4) * settings.contrast;
                    
                    const orbSize = settings.orbsize;
                    fractal.position.x = Math.sin(this.time + level) * amplitude * 4 * orbSize + settings.center;
                    fractal.position.y = Math.cos(this.time * 1.3 + level) * amplitude * 4 * orbSize;
                    fractal.position.z = Math.sin(this.time * 0.7 + level) * amplitude * 3 * orbSize;
                    
                    const hue = (amplitude * settings.colorshift + analysis.peak * 0.5 + this.time * 0.1) % 1;
                    fractal.material.color.setHSL(hue, 0.9, 0.6 + amplitude * 0.3);
                    fractal.material.emissive.setHSL(hue, 1.0, 0.4 + amplitude * 0.4);
                });
            }

            updateColors(colors) {
                this.colors = colors;
                this.fractals.forEach(fractal => {
                    fractal.material.color.setHex(colors.primary);
                    fractal.material.emissive.setHex(colors.primary);
                });
                if (this.pointLight) {
                    this.pointLight.color.setHex(colors.accent);
                }
            }

            dispose() {
                this.fractals.forEach(fractal => {
                    this.scene.remove(fractal);
                    fractal.geometry.dispose();
                    fractal.material.dispose();
                });
                this.fractals = [];
            }
        }

        // Enhanced Endless 3D Tunnel Visualizer
        class EnhancedTunnelVisualizer {
            constructor(scene, colors, performance) {
                this.scene = scene;
                this.colors = colors;
                this.performance = performance;
                this.tunnelWalls = [];
                this.tunnelRings = [];
                this.particles = [];
                this.pointLights = [];
                this.burstParticles = [];
                this.time = 0;
                this.tunnelPosition = 0;
                this.lastBeatTime = 0;
                this.energyHistory = [];
                this.tunnelPulse = 1.0;
                this.createEndlessTunnel();
            }

            createEndlessTunnel() {
                const segmentCount = this.performance === 'high' ? 60 : this.performance === 'medium' ? 45 : 30;
                const segmentSpacing = 1.5;
                const tunnelRadius = 4.0;
                const wallSegments = this.performance === 'high' ? 20 : this.performance === 'medium' ? 16 : 12;
                
                // Create continuous tunnel walls without segments that reset
                for (let i = 0; i < segmentCount; i++) {
                    const zPosition = -i * segmentSpacing;
                    
                    // Create tunnel wall ring
                    for (let j = 0; j < wallSegments; j++) {
                        const angle = (j / wallSegments) * Math.PI * 2;
                        
                        // Create individual wall panels for seamless movement
                        const geometry = new THREE.PlaneGeometry(0.8, segmentSpacing * 1.2);
                        const material = new THREE.MeshBasicMaterial({
                            color: this.colors.primary,
                            transparent: true,
                            opacity: 0.7,
                            side: THREE.DoubleSide,
                            blending: THREE.AdditiveBlending
                        });
                        
                        const wallPanel = new THREE.Mesh(geometry, material);
                        const x = Math.cos(angle) * tunnelRadius;
                        const y = Math.sin(angle) * tunnelRadius;
                        
                        wallPanel.position.set(x, y, zPosition);
                        wallPanel.lookAt(x * 2, y * 2, zPosition);
                        
                        wallPanel.userData = {
                            wallIndex: j,
                            angle: angle,
                            baseZ: zPosition,
                            segmentIndex: i,
                            baseOpacity: 0.7,
                            baseRadius: tunnelRadius,
                            pulsePhase: Math.random() * Math.PI * 2,
                            beatScale: 1.0
                        };
                        
                        this.tunnelWalls.push(wallPanel);
                        this.scene.add(wallPanel);
                    }
                    
                    // Add wireframe rings for structure
                    const ringGeometry = new THREE.RingGeometry(tunnelRadius * 0.95, tunnelRadius * 1.05, wallSegments);
                    const ringMaterial = new THREE.MeshBasicMaterial({
                        color: this.colors.accent,
                        transparent: true,
                        opacity: 0.4,
                        side: THREE.DoubleSide,
                        wireframe: true,
                        blending: THREE.AdditiveBlending
                    });
                    
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.position.z = zPosition;
                    ring.userData = {
                        baseZ: zPosition,
                        segmentIndex: i,
                        beatScale: 1.0,
                        pulseIntensity: 0
                    };
                    
                    this.tunnelRings.push(ring);
                    this.scene.add(ring);
                }

                // Add flowing particles for motion enhancement
                const particleCount = this.performance === 'high' ? 200 : this.performance === 'medium' ? 150 : 100;
                for (let i = 0; i < particleCount; i++) {
                    const particleGeometry = new THREE.SphereGeometry(0.02, 4, 4);
                    const particleMaterial = new THREE.MeshBasicMaterial({
                        color: this.colors.accent,
                        transparent: true,
                        opacity: 0.8,
                        blending: THREE.AdditiveBlending
                    });
                    
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 2 + Math.random() * 3;
                    
                    particle.position.set(
                        Math.cos(angle) * radius,
                        Math.sin(angle) * radius,
                        -Math.random() * segmentCount * segmentSpacing
                    );
                    
                    particle.userData = {
                        speed: 0.5 + Math.random() * 2,
                        angle: angle,
                        radius: radius,
                        baseZ: particle.position.z,
                        beatScale: 1.0,
                        burstIntensity: 0
                    };
                    
                    this.particles.push(particle);
                    this.scene.add(particle);
                }

                // Create beat-reactive burst particles
                const burstCount = this.performance === 'high' ? 100 : this.performance === 'medium' ? 75 : 50;
                for (let i = 0; i < burstCount; i++) {
                    const burstGeometry = new THREE.SphereGeometry(0.03, 4, 4);
                    const burstMaterial = new THREE.MeshBasicMaterial({
                        color: this.colors.accent,
                        transparent: true,
                        opacity: 0,
                        blending: THREE.AdditiveBlending
                    });
                    
                    const burstParticle = new THREE.Mesh(burstGeometry, burstMaterial);
                    burstParticle.userData = {
                        active: false,
                        life: 0,
                        maxLife: 1.0,
                        velocity: new THREE.Vector3(),
                        baseSize: 0.03
                    };
                    
                    this.burstParticles.push(burstParticle);
                    this.scene.add(burstParticle);
                }

                // Dynamic fog for depth
                this.scene.fog = new THREE.Fog(0x000000, 8, segmentCount * segmentSpacing * 0.7);
                
                // Enhanced lighting setup
                const ambientLight = new THREE.AmbientLight(0x222244, 0.4);
                this.scene.add(ambientLight);
                
                // Multiple moving point lights
                for (let i = 0; i < 3; i++) {
                    const pointLight = new THREE.PointLight(this.colors.primary, 1.5, 12);
                    pointLight.position.set(
                        Math.cos(i * 2.1) * 2,
                        Math.sin(i * 2.1) * 2,
                        5 - i * 3
                    );
                    pointLight.userData = { 
                        index: i, 
                        baseIntensity: 1.5,
                        beatBoost: 0,
                        pulsePhase: i * Math.PI * 0.6
                    };
                    this.scene.add(pointLight);
                    this.pointLights.push(pointLight);
                }
            }

            update(audioData, settings, analysis) {
                if (!audioData) {
                    const time = Date.now() * 0.001;
                    audioData = new Uint8Array(1024);
                    for (let i = 0; i < audioData.length; i++) {
                        audioData[i] = Math.sin(time + i * 0.02) * 60 + 120;
                    }
                }

                this.time += 0.016 * settings.speed;
                
                // Enhanced energy tracking for beat detection
                this.energyHistory.push(analysis.rms);
                if (this.energyHistory.length > 20) {
                    this.energyHistory.shift();
                }
                
                const avgEnergy = this.energyHistory.reduce((sum, e) => sum + e, 0) / this.energyHistory.length;
                const isBeat = analysis.rms > avgEnergy * 1.4 && (this.time - this.lastBeatTime) > 0.2;
                
                if (isBeat) {
                    this.lastBeatTime = this.time;
                    this.triggerBeatEffects(analysis);
                }
                
                // Dynamic tunnel speed based on energy
                const energyBoost = 1 + analysis.rms * 2;
                const bassBoost = 1 + analysis.bass * 3;
                const tunnelSpeed = (0.8 + analysis.bass * 2.5) * settings.speed * energyBoost;
                this.tunnelPosition += tunnelSpeed * 0.15;
                
                // Global tunnel pulse effect
                this.tunnelPulse = Math.max(0.8, this.tunnelPulse * 0.95);
                if (isBeat) {
                    this.tunnelPulse = 1.5 + analysis.rms * 2;
                }

                // Update tunnel walls with extreme audio reactivity
                this.tunnelWalls.forEach((wall, wallIndex) => {
                    const segmentIndex = wall.userData.segmentIndex;
                    const freqIndex = Math.floor((wallIndex / this.tunnelWalls.length) * audioData.length);
                    const amplitude = audioData[freqIndex] / 255;
                    
                    // Continuous Z position movement with proper cycling
                    wall.position.z = wall.userData.baseZ + this.tunnelPosition;
                    
                    // Seamless reset when wall passes camera
                    const segmentCount = this.performance === 'high' ? 60 : this.performance === 'medium' ? 45 : 30;
                    const totalTunnelLength = segmentCount * 1.5;
                    
                    if (wall.position.z > 15) {
                        wall.position.z -= totalTunnelLength;
                        wall.userData.baseZ -= totalTunnelLength;
                    }
                    
                    // MUCH more aggressive audio-reactive effects
                    const pulseIntensity = Math.sin(this.time * 8 + wallIndex * 0.5) * 0.5 + 0.5;
                    const audioReactivity = (analysis.bass * 2.0 + analysis.mid * 1.5 + analysis.treble * 1.0);
                    const beatBoost = wall.userData.beatScale;
                    
                    // Enhanced opacity with beat reactions
                    wall.material.opacity = Math.min(1.0, 
                        (wall.userData.baseOpacity + audioReactivity * 1.2 * pulseIntensity + beatBoost * 0.5) * settings.contrast
                    );
                    
                    // MUCH more dramatic radius modulation
                    const originalAngle = wall.userData.angle;
                    const baseRadiusVariation = 1 + amplitude * settings.orbsize * 1.5;
                    const beatRadiusBoost = this.tunnelPulse;
                    const audioRadiusBoost = 1 + (analysis.bass * 1.5 + analysis.mid * 1.0 + analysis.treble * 0.5);
                    
                    const tunnelRadius = wall.userData.baseRadius * baseRadiusVariation * beatRadiusBoost * audioRadiusBoost * settings.zoom;
                    
                    // Extreme audio-reactive warping and deformation
                    const warpAmount = amplitude * settings.intensity * 1.5 + analysis.rms * 2.0;
                    const angleOffset = this.time * settings.rotation * 0.25 + 
                                     Math.sin(this.time * 4 + wallIndex * 0.5) * warpAmount * 0.5 +
                                     analysis.bass * Math.PI * 0.1;
                    
                    // Add frequency-specific deformation
                    const bassDeform = analysis.bass * Math.sin(this.time * 6 + wallIndex * 0.3) * 0.8;
                    const midDeform = analysis.mid * Math.cos(this.time * 4 + wallIndex * 0.7) * 0.6;
                    const trebleDeform = analysis.treble * Math.sin(this.time * 10 + wallIndex * 0.1) * 0.4;
                    
                    const x = Math.cos(originalAngle + angleOffset) * tunnelRadius + settings.center * 6 + bassDeform;
                    const y = Math.sin(originalAngle + angleOffset) * tunnelRadius + midDeform;
                    
                    // Much more dramatic Z-axis movement
                    const zOffset = Math.sin(this.time * 3 + wallIndex * 0.4) * amplitude * 1.5 + trebleDeform;
                    
                    wall.position.x = x;
                    wall.position.y = y;
                    wall.position.z += zOffset * 0.5;
                    
                    // Beat-reactive wall scaling
                    wall.userData.beatScale = Math.max(1.0, wall.userData.beatScale * 0.92);
                    
                    // Ultra-dynamic color cycling with beat reactions
                    const colorPhase = amplitude * settings.colorshift * 2.0 + this.time * 0.3 + wallIndex * 0.1;
                    const beatColorBoost = isBeat ? 0.5 : 0;
                    
                    // Blend between theme colors more aggressively
                    const primaryColor = new THREE.Color(this.colors.primary);
                    const secondaryColor = new THREE.Color(this.colors.secondary);
                    const accentColor = new THREE.Color(this.colors.accent);
                    
                    let finalColor;
                    if (amplitude > 0.7) {
                        // High frequency -> accent color dominance
                        finalColor = accentColor.clone().lerp(primaryColor, Math.sin(colorPhase) * 0.5 + 0.5);
                    } else if (amplitude > 0.4) {
                        // Mid frequency -> secondary color dominance
                        finalColor = secondaryColor.clone().lerp(accentColor, Math.cos(colorPhase * 1.5) * 0.5 + 0.5);
                    } else {
                        // Low frequency -> primary color dominance
                        finalColor = primaryColor.clone().lerp(secondaryColor, Math.sin(colorPhase * 0.8) * 0.5 + 0.5);
                    }
                    
                    // Beat flash effect
                    if (beatColorBoost > 0) {
                        finalColor.lerp(new THREE.Color(0xffffff), beatColorBoost * analysis.rms);
                    }
                    
                    wall.material.color.copy(finalColor);
                    
                    // Extreme scale variation for breathing effect
                    const audioScale = 1 + amplitude * settings.intensity * 1.5 + analysis.rms * 2.0;
                    const beatScale = wall.userData.beatScale;
                    wall.scale.set(audioScale * beatScale, audioScale * beatScale, 1);
                });

                // Update tunnel rings with extreme reactivity
                this.tunnelRings.forEach((ring, ringIndex) => {
                    ring.position.z = ring.userData.baseZ + this.tunnelPosition;
                    
                    const segmentCount = this.performance === 'high' ? 60 : this.performance === 'medium' ? 45 : 30;
                    const totalTunnelLength = segmentCount * 1.5;
                    
                    if (ring.position.z > 15) {
                        ring.position.z -= totalTunnelLength;
                        ring.userData.baseZ -= totalTunnelLength;
                    }
                    
                    const freqIndex = Math.floor((ringIndex / this.tunnelRings.length) * audioData.length);
                    const amplitude = audioData[freqIndex] / 255;
                    
                    // Much more aggressive ring rotation and scaling
                    const rotationSpeed = (0.02 + amplitude * 0.2 + analysis.rms * 0.3) * settings.rotation;
                    ring.rotation.z += rotationSpeed;
                    
                    // Beat-reactive ring expansion
                    ring.userData.beatScale = Math.max(1.0, ring.userData.beatScale * 0.9);
                    ring.userData.pulseIntensity = Math.max(0, ring.userData.pulseIntensity * 0.85);
                    
                    const audioScale = (1 + amplitude * settings.intensity * 2.0 + analysis.rms * 3.0) * settings.zoom;
                    const beatScale = ring.userData.beatScale;
                    const pulseScale = 1 + ring.userData.pulseIntensity;
                    
                    ring.scale.setScalar(audioScale * beatScale * pulseScale);
                    
                    // Extreme ring color reactivity
                    const accentColor = new THREE.Color(this.colors.accent);
                    const secondaryColor = new THREE.Color(this.colors.secondary);
                    const primaryColor = new THREE.Color(this.colors.primary);
                    
                    const colorMix1 = Math.sin(amplitude * settings.colorshift * 3.0 + this.time * 0.5 + ringIndex * 0.2) * 0.5 + 0.5;
                    const colorMix2 = Math.cos(analysis.rms * 6.0 + this.time * 0.3) * 0.5 + 0.5;
                    
                    let finalColor = accentColor.clone().lerp(secondaryColor, colorMix1);
                    finalColor.lerp(primaryColor, colorMix2);
                    
                    // Beat flash for rings
                    if (isBeat && ringIndex % 3 === 0) {
                        finalColor.lerp(new THREE.Color(0xffffff), analysis.rms * 0.7);
                    }
                    
                    ring.material.color.copy(finalColor);
                    ring.material.opacity = Math.min(1.0, (0.4 + amplitude * 1.5 + analysis.rms * 2.0) * settings.contrast);
                });

                // Update flowing particles with burst effects
                this.particles.forEach((particle, particleIndex) => {
                    const freqIndex = Math.floor((particleIndex / this.particles.length) * audioData.length);
                    const amplitude = audioData[particleIndex % audioData.length] / 255;
                    
                    // Much faster particle movement with audio boost
                    const speedBoost = 1 + analysis.bass * 4 + analysis.rms * 3;
                    particle.position.z += (particle.userData.speed + speedBoost) * settings.speed * 0.8;
                    
                    const segmentCount = this.performance === 'high' ? 60 : this.performance === 'medium' ? 45 : 30;
                    const totalTunnelLength = segmentCount * 1.5;
                    
                    if (particle.position.z > 10) {
                        particle.position.z -= totalTunnelLength;
                        // Reset burst intensity when particle cycles
                        particle.userData.burstIntensity = 0;
                    }
                    
                    // More aggressive orbital motion
                    const time = this.time * (1.0 + analysis.rms * 2.0) + particleIndex * 0.1;
                    const angle = particle.userData.angle + time * settings.rotation * 2.0;
                    const baseRadius = particle.userData.radius;
                    const audioRadius = baseRadius + amplitude * settings.orbsize * 3.0 + analysis.rms * 4.0;
                    
                    // Add chaotic motion on high energy
                    const chaos = analysis.rms > 0.6 ? (Math.random() - 0.5) * analysis.rms * 2.0 : 0;
                    
                    particle.position.x = Math.cos(angle) * audioRadius + settings.center * 4 + chaos;
                    particle.position.y = Math.sin(angle) * audioRadius + chaos * 0.5;
                    
                    // Beat-reactive particle scaling
                    particle.userData.beatScale = Math.max(1.0, particle.userData.beatScale * 0.88);
                    particle.userData.burstIntensity = Math.max(0, particle.userData.burstIntensity * 0.9);
                    
                    const audioScale = (1 + amplitude * settings.intensity * 4.0 + analysis.rms * 5.0) * settings.zoom;
                    const beatScale = particle.userData.beatScale;
                    const burstScale = 1 + particle.userData.burstIntensity;
                    
                    particle.scale.setScalar(audioScale * beatScale * burstScale);
                    
                    // Extreme particle color reactivity
                    const accentColor = new THREE.Color(this.colors.accent);
                    const primaryColor = new THREE.Color(this.colors.primary);
                    const secondaryColor = new THREE.Color(this.colors.secondary);
                    
                    const colorPhase = amplitude * settings.colorshift * 4.0 + this.time * 0.4 + particleIndex * 0.1;
                    const energyMix = analysis.rms * 3.0;
                    
                    let finalColor;
                    if (analysis.treble > 0.5) {
                        finalColor = accentColor.clone().lerp(new THREE.Color(0xffffff), analysis.treble * 0.5);
                    } else if (analysis.mid > 0.5) {
                        finalColor = secondaryColor.clone().lerp(accentColor, Math.sin(colorPhase) * 0.5 + 0.5);
                    } else {
                        finalColor = primaryColor.clone().lerp(secondaryColor, Math.cos(colorPhase * 1.5) * 0.5 + 0.5);
                    }
                    
                    // Beat flash for particles
                    if (isBeat && Math.random() < 0.3) {
                        finalColor.lerp(new THREE.Color(0xffffff), analysis.rms);
                    }
                    
                    particle.material.color.copy(finalColor);
                    particle.material.opacity = Math.min(1.0, (0.6 + amplitude * 2.0 + analysis.rms * 3.0) * settings.contrast);
                });

                // Update burst particles
                this.burstParticles.forEach(burst => {
                    if (burst.userData.active) {
                        burst.userData.life += 0.016;
                        const lifeRatio = burst.userData.life / burst.userData.maxLife;
                        
                        if (lifeRatio >= 1.0) {
                            burst.userData.active = false;
                            burst.material.opacity = 0;
                        } else {
                            // Move burst particle
                            burst.position.add(burst.userData.velocity);
                            
                            // Scale and fade out
                            const scale = (1 - lifeRatio) * (1 + analysis.rms * 2);
                            burst.scale.setScalar(scale);
                            burst.material.opacity = (1 - lifeRatio) * 0.8 * settings.contrast;
                            
                            // Color shift during burst
                            const hue = (lifeRatio * 0.3 + this.time * 0.5) % 1;
                            burst.material.color.setHSL(hue, 0.9, 0.8);
                        }
                    }
                });

                // Update multiple point lights with extreme reactivity
                this.pointLights.forEach((light, lightIndex) => {
                    if (light) {
                        const phase = this.time * (1.5 + lightIndex * 0.5);
                        const audioInfluence = [analysis.bass, analysis.mid, analysis.treble][lightIndex] || 0;
                        
                        // Much more dramatic light movement
                        const orbitRadius = 3 + audioInfluence * 8 * settings.orbsize;
                        const heightVariation = audioInfluence * 6 + analysis.rms * 4;
                        
                        light.position.z = 5 + Math.sin(phase) * 8 + heightVariation;
                        light.position.x = Math.cos(phase * 0.7) * orbitRadius + settings.center * 6;
                        light.position.y = Math.sin(phase * 0.5) * orbitRadius;
                        
                        // Beat-reactive light intensity
                        light.userData.beatBoost = Math.max(0, light.userData.beatBoost * 0.85);
                        const audioIntensity = light.userData.baseIntensity + audioInfluence * 8 + analysis.rms * 10;
                        const beatIntensity = light.userData.beatBoost;
                        
                        light.intensity = (audioIntensity + beatIntensity) * settings.contrast;
                        
                        // Extreme light color cycling
                        const colors = [this.colors.primary, this.colors.secondary, this.colors.accent];
                        const themeColor = new THREE.Color(colors[lightIndex] || this.colors.primary);
                        
                        const hueShift = (audioInfluence * settings.colorshift * 2.0 + this.time * 0.3 + lightIndex * 0.4) % 1;
                        const saturationBoost = 0.9 + analysis.rms * 0.1;
                        const lightnessBoost = 0.7 + audioInfluence * 0.3;
                        
                        const dynamicColor = new THREE.Color().setHSL(hueShift, saturationBoost, lightnessBoost);
                        const mixRatio = 0.3 + audioInfluence * 0.7;
                        const finalColor = themeColor.clone().lerp(dynamicColor, mixRatio);
                        
                        // Beat flash for lights
                        if (isBeat && lightIndex === Math.floor(this.time * 10) % 3) {
                            finalColor.lerp(new THREE.Color(0xffffff), analysis.rms * 0.8);
                        }
                        
                        light.color.copy(finalColor);
                        light.distance = 20 + audioInfluence * 25 + analysis.rms * 30;
                    }
                });
            }

            triggerBeatEffects(analysis) {
                // Trigger wall beat scaling
                this.tunnelWalls.forEach(wall => {
                    wall.userData.beatScale = 1.5 + analysis.rms * 2.0;
                });
                
                // Trigger ring beat expansion
                this.tunnelRings.forEach(ring => {
                    ring.userData.beatScale = 1.8 + analysis.rms * 2.5;
                    ring.userData.pulseIntensity = 1.0 + analysis.rms;
                });
                
                // Trigger particle burst scaling
                this.particles.forEach(particle => {
                    particle.userData.beatScale = 1.6 + analysis.rms * 3.0;
                    particle.userData.burstIntensity = 2.0 + analysis.rms * 2.0;
                });
                
                // Trigger light beat boost
                this.pointLights.forEach(light => {
                    if (light) {
                        light.userData.beatBoost = 15 + analysis.rms * 20;
                    }
                });
                
                // Trigger burst particles
                const burstCount = Math.floor(5 + analysis.rms * 15);
                let burstTriggered = 0;
                
                this.burstParticles.forEach(burst => {
                    if (!burst.userData.active && burstTriggered < burstCount) {
                        burst.userData.active = true;
                        burst.userData.life = 0;
                        burst.userData.maxLife = 0.5 + Math.random() * 1.0;
                        
                        // Position burst at camera with random direction
                        const angle = Math.random() * Math.PI * 2;
                        const speed = 0.1 + Math.random() * 0.3 + analysis.rms * 0.4;
                        
                        burst.position.set(
                            Math.random() * 2 - 1,
                            Math.random() * 2 - 1,
                            5 + Math.random() * 5
                        );
                        
                        burst.userData.velocity.set(
                            Math.cos(angle) * speed,
                            Math.sin(angle) * speed,
                            (Math.random() - 0.5) * speed * 0.5
                        );
                        
                        burstTriggered++;
                    }
                });
            }

            updateColors(colors) {
                this.colors = colors;
                
                // Update tunnel walls
                this.tunnelWalls.forEach(wall => {
                    wall.material.color.setHex(colors.primary);
                });
                
                // Update tunnel rings
                this.tunnelRings.forEach(ring => {
                    ring.material.color.setHex(colors.accent);
                });
                
                // Update particles
                this.particles.forEach(particle => {
                    particle.material.color.setHex(colors.accent);
                });
                
                // Update lights
                this.pointLights.forEach((light, index) => {
                    if (light) {
                        const lightColors = [colors.primary, colors.secondary, colors.accent];
                        light.color.setHex(lightColors[index] || colors.primary);
                    }
                });
            }

            dispose() {
                // Dispose tunnel walls
                this.tunnelWalls.forEach(wall => {
                    this.scene.remove(wall);
                    wall.geometry.dispose();
                    wall.material.dispose();
                });
                
                // Dispose tunnel rings
                this.tunnelRings.forEach(ring => {
                    this.scene.remove(ring);
                    ring.geometry.dispose();
                    ring.material.dispose();
                });
                
                // Dispose particles
                this.particles.forEach(particle => {
                    this.scene.remove(particle);
                    particle.geometry.dispose();
                    particle.material.dispose();
                });
                
                this.tunnelWalls = [];
                this.tunnelRings = [];
                this.particles = [];
                this.pointLights = [];
                this.scene.fog = null;
            }
        }

        // Fullscreen Psychedelic Fractal Visualizer
        class FullscreenPsychedelicVisualizer {
            constructor(scene, colors, performance) {
                this.scene = scene;
                this.colors = colors;
                this.performance = performance;
                this.time = 0;
                this.plane = null;
                this.createPsychedelicShader();
            }

            createPsychedelicShader() {
                const geometry = new THREE.PlaneGeometry(2, 2);
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        u_res: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                        u_time: { value: 0 },
                        u_bass: { value: 0 },
                        u_mid: { value: 0 },
                        u_treble: { value: 0 },
                        u_center: { value: new THREE.Vector2(0.0, 0.0) },
                        u_scale: { value: 1.0 },
                        u_rot: { value: 0 },
                        u_symmetry: { value: 6.0 },
                        u_maxIter: { value: 50.0 },
                        u_warp: { value: 0.1 },
                        u_distortion: { value: 0.5 },
                        u_kaleidoscope: { value: 1.0 },
                        u_morphing: { value: 0.8 },
                        u_fractal: { value: 1.0 },
                        colorPrimary: { value: new THREE.Color(this.colors.primary) },
                        colorSecondary: { value: new THREE.Color(this.colors.secondary) },
                        colorAccent: { value: new THREE.Color(this.colors.accent) }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        precision mediump float;
                        
                        uniform vec2 u_res;
                        uniform float u_time;
                        uniform float u_bass;
                        uniform float u_mid;
                        uniform float u_treble;
                        uniform vec2 u_center;
                        uniform float u_scale;
                        uniform float u_rot;
                        uniform float u_symmetry;
                        uniform float u_maxIter;
                        uniform float u_warp;
                        uniform float u_distortion;
                        uniform float u_kaleidoscope;
                        uniform float u_morphing;
                        uniform float u_fractal;
                        uniform vec3 colorPrimary;
                        uniform vec3 colorSecondary;
                        uniform vec3 colorAccent;
                        
                        varying vec2 vUv;

                        mat2 rot(float a) { 
                            float s = sin(a), c = cos(a); 
                            return mat2(c, -s, s, c); 
                        }

                        vec2 distort(vec2 uv, float time, float intensity) {
                            uv += vec2(
                                sin(uv.y * 8.0 + time * 2.0) * intensity,
                                cos(uv.x * 6.0 - time * 1.5) * intensity
                            );
                            
                            float r = length(uv);
                            float angle = atan(uv.y, uv.x);
                            angle += sin(r * 5.0 + time) * intensity * 0.5;
                            r += sin(angle * 3.0 + time * 0.7) * intensity * 0.3;
                            
                            return vec2(cos(angle) * r, sin(angle) * r);
                        }

                        vec2 kaleidoscope(vec2 uv, float sides, float morphing) {
                            float angle = atan(uv.y, uv.x);
                            float radius = length(uv);
                            
                            float dynamicSides = sides + sin(u_time * 0.3) * morphing * 2.0;
                            float slice = 6.28318 / dynamicSides;
                            angle = mod(angle, slice);
                            if (angle > slice * 0.5) angle = slice - angle;
                            
                            angle += radius * morphing * 0.5 + u_time * 0.2;
                            
                            return vec2(cos(angle) * radius, sin(angle) * radius);
                        }

                        float fractalPattern(vec2 uv, float time, float depth) {
                            vec2 z = vec2(0.0);
                            vec2 c = uv;
                            float it = 0.0;
                            
                            for(int i = 0; i < 50; i++) {
                                if(it >= u_maxIter * depth) break;
                                if(dot(z, z) > 4.0) break;
                                
                                vec2 z2 = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;
                                z2 += vec2(sin(time + it * 0.1), cos(time * 0.7 + it * 0.1)) * u_morphing * 0.1;
                                z = z2;
                                
                                it += 1.0;
                            }
                            
                            return it / (u_maxIter * depth);
                        }

                        void main() {
                            vec2 uv = (vUv - 0.5) * 2.0;
                            
                            uv = distort(uv, u_time, u_distortion * (0.3 + u_bass * 0.7));
                            
                            float swirl = (0.15 + 0.35 * u_treble) * u_time + u_bass * 2.0;
                            uv *= rot(u_rot + swirl);
                            
                            uv = kaleidoscope(uv, u_symmetry, u_morphing);
                            
                            uv += vec2(
                                sin(uv.y * 12.0 + u_time * 1.8) * u_warp * (0.5 + u_mid * 0.5),
                                sin(uv.x * 10.0 - u_time * 2.1) * u_warp * (0.5 + u_treble * 0.5)
                            );
                            
                            vec2 c = u_center + uv * u_scale;
                            
                            float fractal1 = fractalPattern(c, u_time, 1.0);
                            float fractal2 = fractalPattern(c * 1.5 + vec2(0.1, 0.0), u_time * 0.7, u_fractal);
                            float fractal3 = fractalPattern(c * 0.7 + vec2(0.0, 0.1), u_time * 1.3, u_fractal * 0.5);
                            
                            float combined = (fractal1 + fractal2 * 0.7 + fractal3 * 0.5) / 2.2;
                            
                            float hue1 = fract(combined * 2.0 + u_time * 0.3 * (1.0 + u_bass * 2.0));
                            float hue2 = fract(combined * 1.5 + u_time * 0.5 * (1.0 + u_mid * 1.5));
                            float hue3 = fract(combined * 0.8 + u_time * 0.7 * (1.0 + u_treble * 1.0));
                            
                            vec3 color1 = mix(colorPrimary, colorSecondary, sin(hue1 * 6.28318) * 0.5 + 0.5);
                            vec3 color2 = mix(colorSecondary, colorAccent, cos(hue2 * 4.0) * 0.5 + 0.5);
                            vec3 color3 = mix(colorAccent, colorPrimary, sin(hue3 * 8.0) * 0.5 + 0.5);
                            
                            vec3 finalColor = mix(color1, color2, abs(sin(combined * 3.14159 + u_time)));
                            finalColor = mix(finalColor, color3, abs(cos(combined * 6.28318 + u_time * 0.5)));
                            
                            float brightness = 1.0 + sin(combined * 5.0 + u_time * 2.0) * 0.3;
                            brightness *= (1.0 + u_kaleidoscope * (u_bass * 0.8 + u_mid * 0.6 + u_treble * 0.4));
                            
                            finalColor *= brightness;
                            
                            float glow = smoothstep(0.0, 1.0, combined) * (0.3 + u_kaleidoscope * (u_treble * 0.7 + u_bass * 0.3));
                            finalColor += glow * mix(colorAccent, colorPrimary, sin(u_time * 3.0) * 0.5 + 0.5);
                            
                            vec3 gray = vec3(dot(finalColor, vec3(0.299, 0.587, 0.114)));
                            finalColor = mix(gray, finalColor, 1.5 + u_morphing * 0.5);
                            
                            finalColor = pow(finalColor, vec3(0.7));
                            
                            gl_FragColor = vec4(finalColor, 1.0);
                        }
                    `,
                    transparent: false
                });

                this.plane = new THREE.Mesh(geometry, material);
                this.scene.add(this.plane);
            }

            update(audioData, settings, analysis) {
                if (!this.plane) return;

                this.time += 0.016 * settings.speed;
                
                const uniforms = this.plane.material.uniforms;
                uniforms.u_time.value = this.time * 0.5;
                uniforms.u_bass.value = analysis.bass * settings.intensity;
                uniforms.u_mid.value = analysis.mid * settings.intensity;
                uniforms.u_treble.value = analysis.treble * settings.intensity;
                uniforms.u_center.value.set(settings.center * 0.5, 0.0);
                uniforms.u_scale.value = settings.zoom * 2.0;
                uniforms.u_rot.value = this.time * 0.1 * settings.rotation;
                uniforms.u_symmetry.value = settings.sides;
                uniforms.u_maxIter.value = Math.min(settings.maxiter, 80);
                uniforms.u_warp.value = settings.warp * (0.1 + analysis.bass * 0.3);
                uniforms.u_distortion.value = settings.distortion * (0.5 + analysis.peak * 0.5);
                uniforms.u_kaleidoscope.value = settings.kaleidoscope * (1.0 + analysis.treble * 0.5);
                uniforms.u_morphing.value = settings.morphing * (0.8 + analysis.mid * 0.4);
                uniforms.u_fractal.value = settings.fractal;
                
                uniforms.u_res.value.set(window.innerWidth, window.innerHeight);
            }

            updateColors(colors) {
                this.colors = colors;
                if (this.plane) {
                    const uniforms = this.plane.material.uniforms;
                    uniforms.colorPrimary.value.setHex(colors.primary);
                    uniforms.colorSecondary.value.setHex(colors.secondary);
                    uniforms.colorAccent.value.setHex(colors.accent);
                }
            }

            dispose() {
                if (this.plane) {
                    this.scene.remove(this.plane);
                    this.plane.geometry.dispose();
                    this.plane.material.dispose();
                    this.plane = null;
                }
            }
        }

        // Fullscreen DMT Tunnel Visualizer
        class FullscreenDMTVisualizer {
            constructor(scene, colors, performance) {
                this.scene = scene;
                this.colors = colors;
                this.performance = performance;
                this.time = 0;
                this.plane = null;
                this.createDMTShader();
            }

            createDMTShader() {
                const geometry = new THREE.PlaneGeometry(2, 2);
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        u_res: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                        u_time: { value: 0 },
                        u_bass: { value: 0 },
                        u_mid: { value: 0 },
                        u_treble: { value: 0 },
                        u_center: { value: new THREE.Vector2(0.0, 0.0) },
                        u_zoom: { value: 1.0 },
                        u_rotation: { value: 0.0 },
                        u_warp: { value: 1.0 },
                        u_flow: { value: 1.0 },
                        u_complexity: { value: 1.5 },
                        u_colorshift: { value: 2.0 },
                        u_contrast: { value: 1.5 },
                        colorPrimary: { value: new THREE.Color(this.colors.primary) },
                        colorSecondary: { value: new THREE.Color(this.colors.secondary) },
                        colorAccent: { value: new THREE.Color(this.colors.accent) }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        precision mediump float;
                        
                        uniform vec2 u_res;
                        uniform float u_time;
                        uniform float u_bass;
                        uniform float u_mid;
                        uniform float u_treble;
                        uniform vec2 u_center;
                        uniform float u_zoom;
                        uniform float u_rotation;
                        uniform float u_warp;
                        uniform float u_flow;
                        uniform float u_complexity;
                        uniform float u_colorshift;
                        uniform float u_contrast;
                        uniform vec3 colorPrimary;
                        uniform vec3 colorSecondary;
                        uniform vec3 colorAccent;
                        
                        varying vec2 vUv;

                        mat2 rot(float a) {
                            float c = cos(a), s = sin(a);
                            return mat2(c, -s, s, c);
                        }

                        float pattern(vec2 p, float time) {
                            float n = 0.0;
                            n += sin(p.x * 2.0 + time) * cos(p.y * 1.5 + time * 0.7);
                            n += sin(p.x * 3.0 + time * 1.3) * cos(p.y * 2.5 + time * 0.5);
                            n += sin(length(p) * 4.0 + time * 2.0) * 0.5;
                            return n * 0.33;
                        }

                        void main() {
                            vec2 uv = (vUv - 0.5) * 2.0;
                            
                            uv = (uv - u_center) / u_zoom;
                            
                            float totalRotation = u_rotation + u_time * 0.1 + u_bass * 0.5;
                            uv *= rot(totalRotation);
                            
                            float dist = length(uv);
                            float angle = atan(uv.y, uv.x);
                            
                            float z = 1.0 / (dist + 0.1) - u_time * u_flow;
                            
                            vec2 flowUV = uv + vec2(
                                sin(angle * 3.0 + u_time * 0.8) * u_warp * 0.3,
                                cos(angle * 5.0 - u_time * 1.2) * u_warp * 0.2
                            );
                            
                            float tunnel1 = sin(z * 20.0 + pattern(flowUV * 2.0, u_time) * u_complexity);
                            float tunnel2 = cos(z * 15.0 + angle * 8.0 + u_time * 2.0);
                            float tunnel3 = sin(dist * 40.0 - u_time * 3.0 + pattern(flowUV * u_complexity, u_time) * 5.0);
                            
                            float combined = (tunnel1 + tunnel2 * 0.7 + tunnel3 * 0.5) / 2.2;
                            
                            float lattice = sin(angle * 16.0 + u_time) * sin(z * 8.0 + u_time * 1.5);
                            combined += lattice * 0.3;
                            
                            float colorPhase = combined + z * 0.3 + u_time * u_colorshift;
                            
                            vec3 color1 = mix(colorPrimary, colorSecondary, 
                                sin(colorPhase + u_bass * 3.0) * 0.5 + 0.5);
                            vec3 color2 = mix(colorSecondary, colorAccent, 
                                cos(colorPhase * 1.5 + u_mid * 2.0) * 0.5 + 0.5);
                            vec3 color3 = mix(colorAccent, colorPrimary, 
                                sin(colorPhase * 0.7 + u_treble * 4.0) * 0.5 + 0.5);
                            
                            vec3 finalColor = mix(color1, color2, abs(combined));
                            finalColor = mix(finalColor, color3, smoothstep(0.0, 1.0, abs(combined)));
                            
                            finalColor *= (1.0 + sin(z * 5.0 + u_time) * 0.2);
                            
                            float audioBoost = (u_bass * 0.8 + u_mid * 0.6 + u_treble * 0.4) * 2.0;
                            finalColor *= (0.8 + audioBoost) * u_contrast;
                            
                            float energy = sin(z * 10.0 + u_time * 2.0 + combined * 5.0) * 0.3 + 0.7;
                            finalColor *= energy;
                            
                            float glow = 1.0 / (1.0 + dist * dist);
                            finalColor += glow * colorAccent * audioBoost * 0.3;
                            
                            finalColor = pow(finalColor, vec3(0.8));
                            
                            gl_FragColor = vec4(finalColor, 1.0);
                        }
                    `,
                    transparent: false
                });

                this.plane = new THREE.Mesh(geometry, material);
                this.scene.add(this.plane);
            }

            update(audioData, settings, analysis) {
                if (!this.plane) return;

                this.time += 0.016 * settings.speed;
                
                const uniforms = this.plane.material.uniforms;
                uniforms.u_time.value = this.time * 0.3;
                uniforms.u_bass.value = analysis.bass * settings.intensity;
                uniforms.u_mid.value = analysis.mid * settings.intensity;
                uniforms.u_treble.value = analysis.treble * settings.intensity;
                uniforms.u_center.value.set(settings.center * 0.3, 0.0);
                uniforms.u_zoom.value = settings.zoom * 0.8;
                uniforms.u_rotation.value = this.time * 0.05 * settings.rotation;
                uniforms.u_warp.value = settings.warp * (0.5 + analysis.bass * 0.8);
                uniforms.u_flow.value = settings.flow * (0.8 + analysis.mid * 0.7);
                uniforms.u_complexity.value = settings.complexity * (1.0 + analysis.treble * 0.5);
                uniforms.u_colorshift.value = settings.colorshift * 0.5;
                uniforms.u_contrast.value = settings.contrast;
                
                uniforms.u_res.value.set(window.innerWidth, window.innerHeight);
            }

            updateColors(colors) {
                this.colors = colors;
                if (this.plane) {
                    const uniforms = this.plane.material.uniforms;
                    uniforms.colorPrimary.value.setHex(colors.primary);
                    uniforms.colorSecondary.value.setHex(colors.secondary);
                    uniforms.colorAccent.value.setHex(colors.accent);
                }
            }

            dispose() {
                if (this.plane) {
                    this.scene.remove(this.plane);
                    this.plane.geometry.dispose();
                    this.plane.material.dispose();
                    this.plane = null;
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            try {
                new UltimateAudioVisualizer();
            } catch (error) {
                console.error('Failed to initialize visualizer:', error);
                document.getElementById('error-text').textContent = 'Failed to initialize: ' + error.message;
                document.getElementById('error-message').style.display = 'block';
            }
        });
    </script>
</body>
</html>
